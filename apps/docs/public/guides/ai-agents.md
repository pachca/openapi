
# AI агенты

## Пачка как среда для AI-агентов

Пачка — готовая среда для ваших AI-агентов. Упомяните агента в треде — остальное он сделает сам. Агент находится внутри разговора, видит контекст и действует автономно.

- **Агент — участник команды** — действует как сотрудник: читает обсуждения, создаёт задачи, отправляет результаты. Ответственность остаётся за человеком, агент выполняет работу
- **Треды как единица работы** — каждый тред изолирован, агент видит только его содержимое и отвечает туда же, не загрязняя общий чат
- **Сквозные треды** — упомяните любого сотрудника в треде, и он увидит весь контекст, даже если не состоит в исходном чате. Один тред — единая точка координации между людьми и агентом

![Пример работы AI-агента в треде Пачки](/images/ai-agent-kai.jpg)

*Пример работы AI-агента в треде Пачки*


> Как мы сделали AI-агента, который живёт в корпоративном мессенджере — [читайте в блоге Пачки](https://pachca.com/blog/ai-agent-v-korporativnom-messendzhere)


- **Ответ на вопрос** — Читает тред, ищет ответ в базе знаний, отвечает в тот же тред
- **Задача из обсуждения** — Читает историю треда, формирует заголовок и описание, создаёт задачу в трекере
- **Обработка заявок** — Получает заявку в канале, уточняет детали через форму, маршрутизирует ответственному
- **Диагностика CI** — Запрашивает статус CI-проверок, находит упавший джоб, читает логи и отвечает с диагнозом
- **Анализ файла** — Скачивает файл по ссылке из репозитория или веб-страницы, анализирует и отвечает в тред
- **Исследование компании** — Находит сайт компании, определяет размер команды, собирает ключевую информацию в отчёт
- **Мониторинг** — Следит за сообщениями в канале, при триггере отправляет уведомление или выполняет действие
- **Онбординг** — Приветствует нового сотрудника, отправляет инструкции, помогает настроить профиль
- **Личный ассистент** — Напоминает о задачах, готовит дайджест непрочитанного, собирает повестку к встрече
- **Ответы коллегам** — Отвечает на типовые вопросы от коллег, пока вы заняты, используя контекст ваших проектов
- **Поиск упоминаний** — Находит все треды и сообщения, где вас упомянули, и собирает краткую сводку


## Как это работает


  ### Шаг 1. Получение события

Агент получает события через [исходящий вебхук](/guides/webhook) — упоминание по имени, ответ в тред или личное сообщение боту.


  ### Шаг 2. Сбор контекста

Агент читает историю сообщений и информацию о чате, чтобы понять контекст запроса.

    - [Список сообщений чата](GET /messages) — история сообщений треда или чата
    - [Информация о чате](GET /chats/{id}) — участники и тема чата


  ### Шаг 3. Выполнение действий

Агент выполняет нужные действия — отправляет сообщения, создаёт задачи, вызывает внешние сервисы. Реакция-индикатор показывает пользователю, что агент работает.

    - [Новое сообщение](POST /messages) — отправить сообщение в канал или беседу
    - [Новый тред](POST /messages/{id}/thread) — создать тред и ответить
    - [Новая реакция](POST /messages/{id}/reactions) — поставить реакцию-индикатор


  ### Шаг 4. Ответ

Результат агент отправляет обратно в тред или в личные сообщения и снимает реакцию-индикатор.

    - [Новое сообщение](POST /messages) — отправить результат
    - [Удаление реакции](DELETE /messages/{id}/reactions) — снять реакцию-индикатор


## Практические советы

- **Реакции как индикатор** — агент ставит реакцию (например, ⏳) при получении запроса и снимает по завершении. Пользователь сразу видит, что агент работает
- **Один бот — один агент** — создайте отдельного бота для каждого агента, чтобы разделить права и логику
- **Контекст из треда** — читайте историю треда перед ответом, а не только последнее сообщение. Так агент учитывает весь контекст разговора
- **Обработка ошибок** — если агент не может выполнить задачу, пусть он ответит в тред с пояснением, а не молчит. Прозрачность действий важнее идеального результата

## Ресурсы для AI-агентов

### Agent Skills (SKILL.md)

Описание API в формате skill-файлов для подключения к AI-агентам. Каждый скилл покрывает одну предметную область и содержит: полное описание методов API входящих групп с параметрами и схемами, пошаговые сценарии с curl-примерами, обработку ошибок и gotchas (неочевидные ограничения API, которые легко упустить).

### pachca-profile

**Установить статус**

1. PUT /profile/status с `emoji` и `title`

**Сбросить статус**

1. DELETE /profile/status

**Получить кастомные поля профиля**

1. GET /custom_properties?entity_type=User — список дополнительных полей для сотрудников (`id`, `name`, `data_type`)
2. GET /profile — в ответе поле `custom_properties` содержит значения для текущего пользователя

> Параметр `entity_type=User` фильтрует поля по типу сущности. Кастомные поля настраиваются администратором пространства. Значения хранятся в массиве `custom_properties` объекта `user`.

### pachca-users

**Массовое создание сотрудников с тегами**

1. Создай тег (если нужен): POST /group_tags с `{"group_tag": {"name": ...}}`
2. Для каждого сотрудника: POST /users — теги назначаются через поле `list_tags` в теле запроса
3. Или обнови существующего: PUT /users/{id} с `list_tags`

> Создание сотрудников доступно только администраторам и владельцам (не ботам). Нет отдельного эндпоинта "добавить юзера в тег" — теги назначаются через `list_tags` при создании (POST /users) или обновлении (PUT /users/{id}).

**Найти сотрудника по имени или email**

1. GET /users?query=Иван — поиск по имени/email (частичное совпадение)
2. Если нужен точный поиск по email — перебери страницы и отфильтруй на клиенте

> GET /users поддерживает параметр `query` для поиска. Пагинация cursor-based: используй `limit` и `cursor` из `meta`.

**Онбординг нового сотрудника**

1. POST /users с `email`, именем, тегами (`list_tags`) — создать аккаунт
2. POST /chats/{id}/members с `member_ids` — добавить в нужные каналы (онбординг, общий, тематические)
3. POST /messages с `"entity_type": "user"`, `"entity_id": user.id` — отправить welcome-сообщение в личные сообщения

> Шаг 1 требует токена администратора/владельца. Шаги 2-3 можно делать ботом.

**Offboarding сотрудника**

1. PUT /users/{id} с `"suspended": true` — заблокировать доступ
2. Опционально: DELETE /users/{id} — удалить аккаунт полностью

> Приостановка (`suspended`) сохраняет данные, удаление — необратимо. Уточняй политику перед удалением.

**Получить всех сотрудников тега/департамента**

1. GET /group_tags?names[]=Backend — найти тег по названию
2. Из ответа взять `id` тега
3. GET /group_tags/{id}/users с пагинацией (`limit` + `cursor`) — получить всех участников

### pachca-chats

**Создать канал и пригласить участников**

1. POST /chats — `"channel": true` для канала, `false` (по умолчанию) для беседы
2. Участников можно передать сразу при создании: `member_ids` и/или `group_tag_ids` в теле запроса
3. Или добавить позже: POST /chats/{id}/members с `member_ids`, POST /chats/{id}/group_tags с `group_tag_ids`

> `channel` — boolean, не строка. `member_ids` и `group_tag_ids` — опциональны при создании.

**Архивация и управление чатом**

1. Архивировать: PUT /chats/{id}/archive
2. Разархивировать: PUT /chats/{id}/unarchive
3. Изменить роль участника: PUT /chats/{id}/members/{user_id} с `role` (`"admin"` | `"member"`; `"editor"` — только для каналов). Роль создателя чата изменить нельзя.
4. Удалить участника: DELETE /chats/{id}/members/{user_id}
5. Покинуть чат: DELETE /chats/{id}/leave

**Создать проектную беседу из шаблона**

1. POST /chats с `name`, `"channel": false` и `group_tag_ids` (добавить всех участников тега сразу)
2. Или POST /chats → затем POST /chats/{id}/members с `member_ids` + POST /chats/{id}/group_tags с `group_tag_ids`
3. Отправь приветственное сообщение: POST /messages с `"entity_id": chat.id`

> `group_tag_ids` при создании добавляет всех участников тега сразу — удобнее, чем добавлять поштучно.

**Экспорт истории чата**

1. POST /chats/exports с `start_at` и `end_at` (формат YYYY-MM-DD)
2. Из ответа возьми `id` экспорта
3. Polling: GET /chats/exports/{id} до `"status": "completed"`
4. Скачай архив по ссылке из ответа

> Экспорт доступен только Владельцу пространства на тарифе «Корпорация». Polling каждые 5-10 секунд.

**Найти и заархивировать неактивные чаты**

1. GET /chats с пагинацией, `sort[last_message_at]=asc` — сначала самые старые
2. Отфильтруй чаты, где `last_message_at` старше нужного порога
3. Для каждого: PUT /chats/{id}/archive

> Проверяй `"channel": false` — архивация каналов может быть нежелательной. Уточняй у владельца перед массовой архивацией.

### pachca-messages

**Найти чат по имени и отправить сообщение**

1. GET /chats — перебери результаты, найди нужный по полю `name`
2. Отправь POST /messages с `"entity_id": chat.id`

> `entity_type` по умолчанию `"discussion"`, можно не указывать. GET /chats не поддерживает поиск по имени — перебирай страницы.

**Отправить сообщение в канал или беседу (если chat_id известен)**

1. Отправь POST /messages с `"entity_id": chat_id`

> `"entity_type": "discussion"` используется по умолчанию, можно не указывать

**Отправить личное сообщение пользователю**

1. Определи `user_id` получателя (GET /users или из контекста)
2. Отправь POST /messages с `"entity_type": "user"`, `"entity_id": user_id`

> Создавать чат не требуется — он создаётся автоматически

**Ответить в тред (комментарий к сообщению)**

1. Получи или создай тред: POST /messages/{id}/thread (`id` — id родительского сообщения)
2. Из ответа возьми id треда (`thread.id`)
3. Отправь POST /messages с `"entity_type": "thread"`, `"entity_id": thread.id`

> Если тред уже существует, POST /messages/{id}/thread вернёт существующий. Альтернативно можно использовать `"entity_type": "discussion"` + `"entity_id": thread.chat_id`. `skip_invite_mentions: true` — не добавлять упомянутых пользователей в тред автоматически.

**Ответить пользователю, который написал боту**

1. Вебхук содержит `entity_type` — он однозначно определяет контекст: `"user"` — личное сообщение боту, `"thread"` — сообщение в треде, `"discussion"` — сообщение в канале или беседе
2. DM (`entity_type: "user"`): ответь POST /messages с `"entity_type": "user"`, `"entity_id"`: `user_id` из вебхука
3. Тред (`entity_type: "thread"`): вложенных тредов нет — ответь в тот же тред: POST /messages с `"entity_type": "thread"`, `"entity_id"`: `entity_id` из вебхука, `"parent_message_id"`: `id` сообщения пользователя из вебхука
4. Беседа/канал (`entity_type: "discussion"`): выбери стратегию — inline-ответ (POST /messages c `"parent_message_id"`: `id` сообщения) или тред (POST /messages/{id}/thread → ответ в тред)

> `parent_message_id` визуально привязывает ответ к конкретному сообщению (показывается как «в ответ на…»). В треде обязателен для цепочки диалога. В обычном чате — альтернатива треду.

**Отправить сообщение с файлами**

1. Для каждого файла: POST /uploads → получи `key` (с `$filename`), `direct_url`, `policy`, подпись
2. Для каждого файла: подставь имя файла вместо `$filename` в `key`, затем загрузи файл POST на `direct_url` (`multipart/form-data`, без авторизации)
3. Собери массив `files` из всех загруженных файлов (`key`, `name`, `file_type`, `size`)
4. Отправь POST /messages с массивом `files` — одно сообщение со всеми файлами

> Файлы не передаются inline. Загрузка двухшаговая: сначала POST /uploads (параметры), затем POST на `direct_url` (сам файл на S3). Шаги 1-2 повторяются для каждого файла отдельно, а сообщение отправляется один раз со всеми файлами.

**Отправить сообщение с кнопками**

1. Сформируй массив `buttons` — массив строк, каждая строка — массив кнопок: `[[{кнопка1, кнопка2}, ...], ...]`
2. Каждая кнопка: `{"text": "Текст"}` + либо `url` (ссылка), либо `data` (callback для вебхука)
3. Отправь POST /messages с полем `buttons`
4. Нажатия кнопок приходят в исходящий вебхук (событие "Нажатие кнопок")

> `buttons` — массив массивов (строки × кнопки). Максимум 100 кнопок, до 8 в строке. Кнопка с `url` открывает ссылку, с `data` — отправляет событие на вебхук.

**Получить историю сообщений чата**

1. GET /messages?chat_id={id}
2. Пагинация: `limit` (1-50, по умолчанию 50) и `cursor` (из `meta.paginate.next_page`)
3. Сортировка: `sort[id]=asc` или `sort[id]=desc` (по умолчанию `"desc"`)

> Для сообщений треда используй `chat_id` треда (`thread.chat_id`). Пагинация cursor-based, не page-based.

**Закрепить/открепить сообщение**

1. Закрепить: POST /messages/{id}/pin
2. Открепить: DELETE /messages/{id}/pin

> В чате может быть несколько закреплённых сообщений.

**Подписаться на тред сообщения**

1. POST /messages/{id}/thread — если треда нет, он будет создан; если есть — вернётся существующий
2. Из ответа возьми `chat_id` треда (`data.chat_id`)
3. Добавь бота (или пользователя) в участники чата треда: POST /chats/{id}/members с `member_ids`
4. Теперь бот будет получать вебхук-события о новых сообщениях в этом треде

> POST /messages/{id}/thread идемпотентен — безопасно вызывать повторно. После добавления в участники бот получает события треда через исходящий вебхук.

**Упомянуть пользователя по имени**

1. Определи поисковый запрос — используй фамилию, она уникальнее. Имена не склоняются в API, приводи к именительному падежу: «упомяни Пашу» → ищи `Паша` или `Павел`, «тегни Голубева» → ищи `Голубев`
2. Найди пользователя: GET /users?query={запрос}
3. Один подходящий результат → используй `nickname`. Несколько → уточни у пользователя (имя + фамилия). Ничего → попробуй другую форму имени (уменьшительное ↔ полное)
4. Вставь `@nickname` в текст сообщения

> Упоминание — это просто `@nickname` в тексте. Пачка автоматически делает его кликабельным. GET /users поддерживает `query` (частичное совпадение по имени и email).

**Отредактировать сообщение**

1. PUT /messages/{id} с полем `content` (и/или `buttons`, `files`)

> Редактировать можно только свои сообщения (или от имени бота).

**Удалить сообщение**

1. DELETE /messages/{id}

**Добавить реакцию на сообщение**

1. POST /messages/{id}/reactions с полем `code` (emoji)
2. Убрать реакцию: DELETE /messages/{id}/reactions с полем `code`

> `code` — emoji-символ, не его текстовое название.

**Проверить, кто прочитал сообщение**

1. GET /messages/{id}/read_member_ids — возвращает массив `user_id` прочитавших
2. При необходимости сопоставь с GET /users для получения имён

**Разослать уведомление нескольким пользователям**

1. Определи список `user_id` получателей (GET /users или из контекста)
2. Для каждого: POST /messages с `"entity_type": "user"`, `"entity_id": user_id`

> Соблюдай rate limit: ~4 req/sec для сообщений. Добавляй паузы при большом списке.

### pachca-bots

**Настроить бота с исходящим вебхуком**

1. Создай бота в интерфейсе Пачки: Автоматизации → Интеграции → Webhook
2. Получи `access_token` бота во вкладке «API» настроек бота
3. Укажи Webhook URL для получения событий
4. Выбери типы событий: новые сообщения, реакции, кнопки, участники

> Бот создаётся через UI, не через API. Единственный эндпоинт для ботов — PUT /bots/{id} (обновление webhook URL). API используется для отправки сообщений от имени бота.

**Обработать входящий вебхук-событие**

1. Получи POST-запрос на свой Webhook URL
2. Проверь подпись (Signing secret) для безопасности
3. Проверь `webhook_timestamp` — должен быть в пределах 1 минуты
4. Разбери JSON: тип события, данные
5. Для полной информации сделай запрос к API (например, GET /messages/{id})

> Вебхук содержит минимум данных. Для полной информации используй API.

**Разворачивание ссылок (unfurling)**

1. Создай специального Unfurl-бота и укажи отслеживаемые домены в его настройках
2. При появлении ссылки бот получает вебхук `"event": "link_shared"` с массивом `links` (`url` + `domain`) и `message_id`
3. Извлеки данные из своей системы по URL из `links`
4. Отправь POST /messages/{id}/link_previews с превью-данными

> Эндпоинт привязан к конкретному сообщению. Необходим специальный Unfurl-бот с указанными доменами.

**Обработать нажатие кнопки (callback)**

1. Получи вебхук с `"event": "message_button_clicked"` — в payload: `data` (из кнопки), `user_id`, `message_id`
2. Выполни нужное действие (запись в БД, запрос к API и т.д.)
3. Ответь пользователю: POST /messages с `"entity_type": "user"`, `"entity_id": user_id` из вебхука
4. Опционально: обнови исходное сообщение через PUT /messages/{id} (убери кнопки или измени текст)

> Кнопка с `data` отправляет событие на вебхук. Кнопка с `url` — открывает ссылку (вебхука не будет).

**Периодический дайджест/отчёт**

1. По расписанию (cron/scheduler): собери данные из своей системы
2. Сформируй текст сообщения с нужными метриками или сводкой
3. POST /messages с `"entity_id": chat_id` нужного канала

> Нет встроенного планировщика — используй cron, celery, sidekiq и т.п. на своей стороне.

**Мониторинг и алерты**

1. Внешняя система (CI, мониторинг, сервис) обнаруживает событие (ошибка, деплой, порог метрики)
2. Делает POST запрос к твоему боту или напрямую вызывает Pachca API
3. POST /messages в канал алертов с описанием события и кнопками «Взять в работу» / «Игнорировать»
4. При нажатии кнопки — обработай callback и обнови статус алерта

**Обработка событий через историю (polling)**

1. В настройках бота включи «Сохранять историю событий» (вкладка «Исходящий webhook»). Webhook URL указывать не обязательно.
2. По расписанию или по запросу: GET /webhooks/events — получи накопленные события с пагинацией (`limit`, `cursor`)
3. Обработай каждое событие (тот же формат payload, что и в real-time вебхуке)
4. После обработки: DELETE /webhooks/events/{id} — удали событие, чтобы не обработать повторно

> Polling — альтернатива real-time вебхуку, если у бота нет публичного URL или нужна отложенная обработка. Подходит для batch-сценариев, скриптов, serverless-функций по расписанию.

### pachca-forms

**Показать интерактивную форму пользователю**

1. Заранее подготовь объект формы (`view` с `title` и `blocks`) — собери его до получения `trigger_id`
2. Отправь сообщение с кнопкой (POST /messages с `buttons`, в `data` кнопки передай идентификатор формы)
3. При нажатии кнопки — получи вебхук-событие с `trigger_id`
4. Немедленно отправь POST /views/open с `trigger_id` и готовым объектом формы
5. Пользователь заполняет форму → результат приходит на Webhook URL

> `trigger_id` живёт 3 секунды — за это время нужно успеть отправить POST /views/open. Формируй объект формы заранее, а не после получения события. Формы работают только от бота (GET /profile → `"bot": true`).

**Опрос сотрудников через форму**

1. Отправь сообщение с кнопкой «Пройти опрос» в канал или ЛС: POST /messages с `"data": "survey_start"` в кнопке
2. При нажатии кнопки получи вебхук с `trigger_id` и `user_id` нажавшего
3. Немедленно отправь POST /views/open с формой (поля: `text_field`, `select` и т.д.)
4. При отправке формы получи вебхук с результатами (поле `values` в payload)
5. Обработай ответы: сохрани в базу или отправь итоговым сообщением в канал

> Каждый пользователь должен нажать кнопку сам — у каждого свой `trigger_id`. Нельзя открыть форму принудительно.

**Форма заявки/запроса**

1. Размести в канале сообщение с кнопкой «Создать заявку» (`"data": "new_request"`)
2. При нажатии открой форму с полями: тема, описание, приоритет (`select`)
3. При submit-вебхуке: создай задачу (POST /tasks) или отправь уведомление ответственному (POST /messages с `"entity_type": "user"`)
4. Отправь подтверждение автору: POST /messages с `"entity_type": "user"`, `"entity_id": user_id` из вебхука

### pachca-tasks

**Создать напоминание для себя**

1. POST /tasks с `kind`, `content` и `due_at`

> Задачи поддерживают дополнительные поля (`custom_properties`). Передай массив `[{"id": <field_id>, "value": "..."}]` при создании или обновлении. Список доступных полей: GET /custom_properties?entity_type=Task.

**Получить список предстоящих задач**

1. GET /tasks с пагинацией (`limit`, `cursor`)
2. Отфильтруй на клиенте по полю `status`: `"undone"` — не выполнена, `"done"` — выполнена

> Фильтрация по `status` на стороне API не поддерживается — фильтруй самостоятельно после получения.

**Отметить задачу выполненной**

1. PUT /tasks/{id} с `"status": "done"`

**Создать серию напоминаний**

1. Подготовь список дат (ежедневно, еженедельно и т.д.)
2. Для каждой даты: POST /tasks с нужным `kind`, `content` и `due_at`

**Заполнить дополнительные поля задачи**

1. GET /custom_properties?entity_type=Task — получи список доступных полей (`id`, `name`, `data_type`)
2. При создании: POST /tasks с `custom_properties: [{"id": <field_id>, "value": "..."}]`
3. При обновлении: PUT /tasks/{id} с `custom_properties: [{"id": <field_id>, "value": "..."}]`
4. В ответе задачи поле `custom_properties` содержит текущие значения всех полей

> Если передать `id` удалённого или несуществующего поля — получишь ошибку 422. Тип значения в `value` всегда строка (даже для числовых и date-полей). Дополнительные поля настраиваются администратором пространства.

### pachca-security

**Получить журнал аудита событий**

1. GET /audit_events с фильтрами (`event_key`, период, пагинация)
2. Доступные типы событий: входы, изменения прав, действия с чатами и т.д.

> Доступно только владельцу пространства.

**Мониторинг подозрительных входов**

1. GET /audit_events с фильтром `"event_key": "user_2fa_fail"` (или `"user_signed_in"`) за нужный период
2. Пагинируй с `cursor` до получения всех записей
3. Если найдены аномалии (много неудачных 2FA с одного аккаунта) — отправь уведомление администратору через POST /messages

> Фильтрация по `event_key` — строковое совпадение. Доступные ключи — в документации Аудит событий.

**Экспорт логов за период**

1. GET /audit_events с параметрами `created_at[from]` и `created_at[to]` (ISO 8601)
2. Пагинируй с `cursor` до получения всех записей (`limit` до 50)
3. Собери все события в массив → сохрани в файл или отправь во внешнюю систему (SIEM, таблицы)


> Есть предложения по новым сценариям? [Напишите нам](https://github.com/pachca/openapi/issues/new?template=workflow-suggestion.yml) и мы добавим их в скиллы.


Скиллы соответствуют спецификации [Agent Skills](https://agentskills.io) и [Agent Skills Discovery RFC](https://github.com/cloudflare/agent-skills-discovery-rfc), совместимы с 40+ AI-агентами через [Skills CLI](https://skills.sh).

### Другие форматы

- [llms.txt](/llms.txt) — Краткая сводка документации со ссылками на страницы в markdown-формате. Соответствует стандарту llms.txt.
- [llms-full.txt](/llms-full.txt) — Полная документация в одном файле для загрузки в контекст агента. Содержит все руководства и описания методов.
- [OpenAPI-спецификация](/openapi.yaml) — OpenAPI 3.0 спецификация для кодогенерации, парсинга и автоматического создания клиентов.
- [Context7](https://context7.com/pachca/openapi) — Документация Пачки в Context7 — MCP-сервер с актуальной документацией для AI-агентов.


> Любая страница документации доступна в markdown-формате — добавьте `.md` к адресу страницы. Например: `/guides/webhook.md`


## Как подключить Пачку к вашему агенту

### Через Agent Skills (рекомендуется)

Универсальный способ для 40+ AI-агентов (Claude Code, Cursor, Codex, Windsurf, Continue и др.).

**Agent Skills**

```bash
npx skills add pachca/openapi
```


Команда автоматически определит установленные агенты и подключит скиллы Пачки. Агент получит пошаговые сценарии для всех типичных задач — от отправки сообщений до работы с формами.

### Через Context7 MCP

Для AI-агентов с поддержкой MCP (Claude Code, Cursor, Windsurf и др.). [Context7](https://context7.com) — MCP-сервер, который отдаёт актуальную документацию прямо в контекст агента. Документация Пачки доступна по адресу [context7.com/pachca/openapi](https://context7.com/pachca/openapi).

**Claude Code**

```bash
claude mcp add context7 https://mcp.context7.com/mcp
```


Для других агентов добавьте MCP-сервер `https://mcp.context7.com/mcp` в настройках. Чтобы агент использовал документацию Пачки, добавьте в промпт `use context7` или настройте это через правила агента.

### Через llms-full.txt

Подходит для агентов, которые не поддерживают формат Agent Skills, но позволяют загружать текст в контекст (ChatGPT, собственные агенты на базе LLM).

**llms-full.txt**

```text
https://dev.pachca.com/llms-full.txt
```


### Через OpenAPI-спецификацию

Подходит для кодогенераторов (openapi-generator, Kiota, Orval) и агентов, которые умеют работать с OpenAPI напрямую (GPT Actions).

**OpenAPI**

```text
https://dev.pachca.com/openapi.yaml
```

