// Package pachca provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package pachca

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AuditEventKey.
const (
	AccessTokenCreated    AuditEventKey = "access_token_created"
	AccessTokenDestroy    AuditEventKey = "access_token_destroy"
	AccessTokenUpdated    AuditEventKey = "access_token_updated"
	AuditEventsAccessed   AuditEventKey = "audit_events_accessed"
	ChatCreated           AuditEventKey = "chat_created"
	ChatPermissionChanged AuditEventKey = "chat_permission_changed"
	ChatRenamed           AuditEventKey = "chat_renamed"
	DlpViolationDetected  AuditEventKey = "dlp_violation_detected"
	KmsDecrypt            AuditEventKey = "kms_decrypt"
	KmsEncrypt            AuditEventKey = "kms_encrypt"
	MessageCreated        AuditEventKey = "message_created"
	MessageDeleted        AuditEventKey = "message_deleted"
	MessageUpdated        AuditEventKey = "message_updated"
	ReactionCreated       AuditEventKey = "reaction_created"
	ReactionDeleted       AuditEventKey = "reaction_deleted"
	TagAddedToChat        AuditEventKey = "tag_added_to_chat"
	TagCreated            AuditEventKey = "tag_created"
	TagDeleted            AuditEventKey = "tag_deleted"
	TagRemovedFromChat    AuditEventKey = "tag_removed_from_chat"
	ThreadCreated         AuditEventKey = "thread_created"
	User2faFail           AuditEventKey = "user_2fa_fail"
	User2faSuccess        AuditEventKey = "user_2fa_success"
	UserAddedToTag        AuditEventKey = "user_added_to_tag"
	UserChatJoin          AuditEventKey = "user_chat_join"
	UserChatLeave         AuditEventKey = "user_chat_leave"
	UserCreated           AuditEventKey = "user_created"
	UserDeleted           AuditEventKey = "user_deleted"
	UserLogin             AuditEventKey = "user_login"
	UserLogout            AuditEventKey = "user_logout"
	UserRemovedFromTag    AuditEventKey = "user_removed_from_tag"
	UserRoleChanged       AuditEventKey = "user_role_changed"
	UserUpdated           AuditEventKey = "user_updated"
)

// Defines values for ButtonWebhookPayloadEvent.
const (
	Click ButtonWebhookPayloadEvent = "click"
)

// Defines values for ButtonWebhookPayloadType.
const (
	ButtonWebhookPayloadTypeButton ButtonWebhookPayloadType = "button"
)

// Defines values for ChatAvailability.
const (
	IsMember ChatAvailability = "is_member"
	Public   ChatAvailability = "public"
)

// Defines values for ChatMemberRole.
const (
	ChatMemberRoleAdmin  ChatMemberRole = "admin"
	ChatMemberRoleEditor ChatMemberRole = "editor"
	ChatMemberRoleMember ChatMemberRole = "member"
)

// Defines values for ChatMemberRoleFilter.
const (
	ChatMemberRoleFilterAdmin  ChatMemberRoleFilter = "admin"
	ChatMemberRoleFilterAll    ChatMemberRoleFilter = "all"
	ChatMemberRoleFilterEditor ChatMemberRoleFilter = "editor"
	ChatMemberRoleFilterMember ChatMemberRoleFilter = "member"
	ChatMemberRoleFilterOwner  ChatMemberRoleFilter = "owner"
)

// Defines values for ChatMemberWebhookPayloadType.
const (
	ChatMember ChatMemberWebhookPayloadType = "chat_member"
)

// Defines values for CompanyMemberWebhookPayloadType.
const (
	CompanyMember CompanyMemberWebhookPayloadType = "company_member"
)

// Defines values for CustomPropertyDataType.
const (
	CustomPropertyDataTypeDate   CustomPropertyDataType = "date"
	CustomPropertyDataTypeLink   CustomPropertyDataType = "link"
	CustomPropertyDataTypeNumber CustomPropertyDataType = "number"
	CustomPropertyDataTypeString CustomPropertyDataType = "string"
)

// Defines values for FileType.
const (
	FileTypeFile  FileType = "file"
	FileTypeImage FileType = "image"
)

// Defines values for InviteStatus.
const (
	Confirmed InviteStatus = "confirmed"
	Sent      InviteStatus = "sent"
)

// Defines values for LinkSharedWebhookPayloadEvent.
const (
	LinkShared LinkSharedWebhookPayloadEvent = "link_shared"
)

// Defines values for LinkSharedWebhookPayloadType.
const (
	LinkSharedWebhookPayloadTypeMessage LinkSharedWebhookPayloadType = "message"
)

// Defines values for MemberEventType.
const (
	Add    MemberEventType = "add"
	Remove MemberEventType = "remove"
)

// Defines values for MessageCreateRequestMessageFilesFileType.
const (
	MessageCreateRequestMessageFilesFileTypeFile  MessageCreateRequestMessageFilesFileType = "file"
	MessageCreateRequestMessageFilesFileTypeImage MessageCreateRequestMessageFilesFileType = "image"
)

// Defines values for MessageEntityType.
const (
	MessageEntityTypeDiscussion MessageEntityType = "discussion"
	MessageEntityTypeThread     MessageEntityType = "thread"
	MessageEntityTypeUser       MessageEntityType = "user"
)

// Defines values for MessageWebhookPayloadType.
const (
	MessageWebhookPayloadTypeMessage MessageWebhookPayloadType = "message"
)

// Defines values for OAuthScope.
const (
	AuditEventsRead      OAuthScope = "audit_events:read"
	BotsWrite            OAuthScope = "bots:write"
	ChatExportsRead      OAuthScope = "chat_exports:read"
	ChatExportsWrite     OAuthScope = "chat_exports:write"
	ChatMembersRead      OAuthScope = "chat_members:read"
	ChatMembersWrite     OAuthScope = "chat_members:write"
	ChatsArchive         OAuthScope = "chats:archive"
	ChatsCreate          OAuthScope = "chats:create"
	ChatsLeave           OAuthScope = "chats:leave"
	ChatsRead            OAuthScope = "chats:read"
	ChatsUpdate          OAuthScope = "chats:update"
	CustomPropertiesRead OAuthScope = "custom_properties:read"
	FilesRead            OAuthScope = "files:read"
	FilesWrite           OAuthScope = "files:write"
	GroupTagsRead        OAuthScope = "group_tags:read"
	GroupTagsWrite       OAuthScope = "group_tags:write"
	LinkPreviewsWrite    OAuthScope = "link_previews:write"
	MessagesCreate       OAuthScope = "messages:create"
	MessagesDelete       OAuthScope = "messages:delete"
	MessagesRead         OAuthScope = "messages:read"
	MessagesUpdate       OAuthScope = "messages:update"
	PinsWrite            OAuthScope = "pins:write"
	ProfileRead          OAuthScope = "profile:read"
	ProfileStatusRead    OAuthScope = "profile_status:read"
	ProfileStatusWrite   OAuthScope = "profile_status:write"
	ReactionsRead        OAuthScope = "reactions:read"
	ReactionsWrite       OAuthScope = "reactions:write"
	TasksCreate          OAuthScope = "tasks:create"
	TasksDelete          OAuthScope = "tasks:delete"
	TasksRead            OAuthScope = "tasks:read"
	TasksUpdate          OAuthScope = "tasks:update"
	ThreadsCreate        OAuthScope = "threads:create"
	ThreadsRead          OAuthScope = "threads:read"
	UploadsWrite         OAuthScope = "uploads:write"
	UsersCreate          OAuthScope = "users:create"
	UsersDelete          OAuthScope = "users:delete"
	UsersRead            OAuthScope = "users:read"
	UsersUpdate          OAuthScope = "users:update"
	ViewsWrite           OAuthScope = "views:write"
	WebhooksEventsDelete OAuthScope = "webhooks:events:delete"
	WebhooksEventsRead   OAuthScope = "webhooks:events:read"
	WebhooksRead         OAuthScope = "webhooks:read"
	WebhooksWrite        OAuthScope = "webhooks:write"
)

// Defines values for OpenViewRequestType.
const (
	Modal OpenViewRequestType = "modal"
)

// Defines values for ReactionEventType.
const (
	ReactionEventTypeDelete ReactionEventType = "delete"
	ReactionEventTypeNew    ReactionEventType = "new"
)

// Defines values for ReactionWebhookPayloadType.
const (
	ReactionWebhookPayloadTypeReaction ReactionWebhookPayloadType = "reaction"
)

// Defines values for SearchEntityType.
const (
	SearchEntityTypeTask SearchEntityType = "Task"
	SearchEntityTypeUser SearchEntityType = "User"
)

// Defines values for SortOrder.
const (
	Asc  SortOrder = "asc"
	Desc SortOrder = "desc"
)

// Defines values for TaskStatus.
const (
	TaskStatusDone   TaskStatus = "done"
	TaskStatusUndone TaskStatus = "undone"
)

// Defines values for TaskKind.
const (
	Call     TaskKind = "call"
	Email    TaskKind = "email"
	Event    TaskKind = "event"
	Meeting  TaskKind = "meeting"
	Reminder TaskKind = "reminder"
)

// Defines values for TaskUpdateRequestTaskStatus.
const (
	TaskUpdateRequestTaskStatusDone   TaskUpdateRequestTaskStatus = "done"
	TaskUpdateRequestTaskStatusUndone TaskUpdateRequestTaskStatus = "undone"
)

// Defines values for UserEventType.
const (
	UserEventTypeActivate UserEventType = "activate"
	UserEventTypeConfirm  UserEventType = "confirm"
	UserEventTypeDelete   UserEventType = "delete"
	UserEventTypeInvite   UserEventType = "invite"
	UserEventTypeSuspend  UserEventType = "suspend"
	UserEventTypeUpdate   UserEventType = "update"
)

// Defines values for UserRole.
const (
	UserRoleAdmin      UserRole = "admin"
	UserRoleMultiGuest UserRole = "multi_guest"
	UserRoleUser       UserRole = "user"
)

// Defines values for UserUpdateRequestUserRole.
const (
	UserUpdateRequestUserRoleAdmin      UserUpdateRequestUserRole = "admin"
	UserUpdateRequestUserRoleMultiGuest UserUpdateRequestUserRole = "multi_guest"
	UserUpdateRequestUserRoleUser       UserUpdateRequestUserRole = "user"
)

// Defines values for ValidationErrorCode.
const (
	AccessDenied      ValidationErrorCode = "access_denied"
	AlreadyAssigned   ValidationErrorCode = "already_assigned"
	AlreadyExists     ValidationErrorCode = "already_exists"
	Blank             ValidationErrorCode = "blank"
	DisplayedError    ValidationErrorCode = "displayed_error"
	Exclusion         ValidationErrorCode = "exclusion"
	Forbidden         ValidationErrorCode = "forbidden"
	GeneralLimit      ValidationErrorCode = "general_limit"
	In                ValidationErrorCode = "in"
	Inclusion         ValidationErrorCode = "inclusion"
	Invalid           ValidationErrorCode = "invalid"
	InvalidDateRange  ValidationErrorCode = "invalid_date_range"
	InvalidWebhookUrl ValidationErrorCode = "invalid_webhook_url"
	LicensesLimit     ValidationErrorCode = "licenses_limit"
	MaxLength         ValidationErrorCode = "max_length"
	MinLength         ValidationErrorCode = "min_length"
	NotApplicable     ValidationErrorCode = "not_applicable"
	NotAuthorized     ValidationErrorCode = "not_authorized"
	NotFound          ValidationErrorCode = "not_found"
	OwnerProtected    ValidationErrorCode = "owner_protected"
	PaymentRequired   ValidationErrorCode = "payment_required"
	PermissionDenied  ValidationErrorCode = "permission_denied"
	PersonalChat      ValidationErrorCode = "personal_chat"
	RateLimit         ValidationErrorCode = "rate_limit"
	Required          ValidationErrorCode = "required"
	SelfUpdate        ValidationErrorCode = "self_update"
	Taken             ValidationErrorCode = "taken"
	TooLong           ValidationErrorCode = "too_long"
	TriggerExpired    ValidationErrorCode = "trigger_expired"
	TriggerNotFound   ValidationErrorCode = "trigger_not_found"
	Unhandled         ValidationErrorCode = "unhandled"
	UniqueLimit       ValidationErrorCode = "unique_limit"
	UserLimit         ValidationErrorCode = "user_limit"
	WrongEmoji        ValidationErrorCode = "wrong_emoji"
	WrongParams       ValidationErrorCode = "wrong_params"
)

// Defines values for ViewBlockCheckboxType.
const (
	Checkbox ViewBlockCheckboxType = "checkbox"
)

// Defines values for ViewBlockDateType.
const (
	ViewBlockDateTypeDate ViewBlockDateType = "date"
)

// Defines values for ViewBlockDividerType.
const (
	Divider ViewBlockDividerType = "divider"
)

// Defines values for ViewBlockFileInputType.
const (
	FileInput ViewBlockFileInputType = "file_input"
)

// Defines values for ViewBlockHeaderType.
const (
	Header ViewBlockHeaderType = "header"
)

// Defines values for ViewBlockInputType.
const (
	Input ViewBlockInputType = "input"
)

// Defines values for ViewBlockMarkdownType.
const (
	Markdown ViewBlockMarkdownType = "markdown"
)

// Defines values for ViewBlockPlainTextType.
const (
	PlainText ViewBlockPlainTextType = "plain_text"
)

// Defines values for ViewBlockRadioType.
const (
	Radio ViewBlockRadioType = "radio"
)

// Defines values for ViewBlockSelectType.
const (
	Select ViewBlockSelectType = "select"
)

// Defines values for ViewBlockTimeType.
const (
	Time ViewBlockTimeType = "time"
)

// Defines values for WebhookEventType.
const (
	Delete WebhookEventType = "delete"
	New    WebhookEventType = "new"
	Update WebhookEventType = "update"
)

// AccessTokenInfo Информация о текущем OAuth токене
type AccessTokenInfo struct {
	// CreatedAt Дата создания токена
	CreatedAt time.Time `json:"created_at"`

	// ExpiresIn Время жизни токена в секундах
	ExpiresIn *int32 `json:"expires_in"`

	// Id Идентификатор токена
	Id int64 `json:"id"`

	// LastUsedAt Дата последнего использования токена
	LastUsedAt *time.Time `json:"last_used_at"`

	// Name Пользовательское имя токена
	Name *string `json:"name"`

	// RevokedAt Дата отзыва токена
	RevokedAt *time.Time `json:"revoked_at"`

	// Scopes Список скоупов токена
	Scopes []OAuthScope `json:"scopes"`

	// Token Маскированный токен (видны первые 8 и последние 4 символа)
	Token string `json:"token"`

	// UserId Идентификатор владельца токена
	UserId int64 `json:"user_id"`
}

// AddMembersRequest Запрос на добавление участников в чат
type AddMembersRequest struct {
	// MemberIds Массив идентификаторов пользователей, которые станут участниками
	MemberIds []int32 `json:"member_ids"`

	// Silent Не создавать в чате системное сообщение о добавлении участника
	Silent *bool `json:"silent,omitempty"`
}

// AddTagsRequest Запрос на добавление тегов в чат
type AddTagsRequest struct {
	// GroupTagIds Массив идентификаторов тегов, которые станут участниками
	GroupTagIds []int32 `json:"group_tag_ids"`
}

// ApiError Ошибка API (используется для 400, 403, 404, 409, 410, 422)
type ApiError struct {
	// Errors Массив ошибок
	Errors []ApiErrorItem `json:"errors"`
}

// ApiErrorItem Детальная информация об ошибке
type ApiErrorItem struct {
	// Code Код ошибки
	Code ValidationErrorCode `json:"code"`

	// Key Ключ поля с ошибкой
	Key string `json:"key"`

	// Message Сообщение об ошибке
	Message string `json:"message"`

	// Payload Дополнительные данные об ошибке
	Payload *string `json:"payload"`

	// Value Значение поля, которое вызвало ошибку
	Value *string `json:"value"`
}

// AuditEvent Событие аудита
type AuditEvent struct {
	// ActorId Идентификатор пользователя, выполнившего действие
	ActorId string `json:"actor_id"`

	// ActorType Тип актора
	ActorType string `json:"actor_type"`

	// CreatedAt Дата и время создания события (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// Details Дополнительные детали события
	Details map[string]interface{} `json:"details"`

	// EntityId Идентификатор затронутой сущности
	EntityId string `json:"entity_id"`

	// EntityType Тип затронутой сущности
	EntityType string `json:"entity_type"`

	// EventKey Ключ типа события
	EventKey AuditEventKey `json:"event_key"`

	// Id Уникальный идентификатор события
	Id string `json:"id"`

	// IpAddress IP-адрес, с которого было выполнено действие
	IpAddress string `json:"ip_address"`

	// UserAgent User agent клиента
	UserAgent string `json:"user_agent"`
}

// AuditEventKey Тип аудит-события
type AuditEventKey string

// BotResponse Ответ с данными бота
type BotResponse struct {
	// Id Идентификатор бота
	Id int32 `json:"id"`

	// Webhook Объект параметров вебхука
	Webhook struct {
		// OutgoingUrl URL исходящего вебхука
		OutgoingUrl string `json:"outgoing_url"`
	} `json:"webhook"`
}

// BotUpdateRequest Запрос на обновление бота
type BotUpdateRequest struct {
	// Bot Собранный объект параметров редактируемого бота
	Bot struct {
		// Webhook Объект параметров вебхука
		Webhook struct {
			// OutgoingUrl URL исходящего вебхука
			OutgoingUrl string `json:"outgoing_url"`
		} `json:"webhook"`
	} `json:"bot"`
}

// Button Кнопка
type Button struct {
	// Data Данные, которые будут отправлены в исходном вебхуке по нажатию кнопки
	Data *string `json:"data,omitempty"`

	// Text Текст, отображаемый на кнопке
	Text string `json:"text"`

	// Url Ссылка, которая будет открыта по нажатию кнопки
	Url *string `json:"url,omitempty"`
}

// ButtonWebhookPayload Структура исходящего вебхука о нажатии кнопки
type ButtonWebhookPayload struct {
	// ChatId Идентификатор чата, в котором была нажата кнопка
	ChatId int32 `json:"chat_id"`

	// Data Данные нажатой кнопки
	Data string `json:"data"`

	// Event Тип события
	Event ButtonWebhookPayloadEvent `json:"event"`

	// MessageId Идентификатор сообщения, к которому относится кнопка
	MessageId int32 `json:"message_id"`

	// TriggerId Уникальный идентификатор события. Время жизни — 3 секунды. Может быть использован, например, для открытия представления пользователю
	TriggerId string `json:"trigger_id"`

	// Type Тип объекта
	Type ButtonWebhookPayloadType `json:"type"`

	// UserId Идентификатор пользователя, который нажал кнопку
	UserId int32 `json:"user_id"`

	// WebhookTimestamp Дата и время отправки вебхука (UTC+0) в формате UNIX
	WebhookTimestamp int32 `json:"webhook_timestamp"`
}

// ButtonWebhookPayloadEvent Тип события
type ButtonWebhookPayloadEvent string

// ButtonWebhookPayloadType Тип объекта
type ButtonWebhookPayloadType string

// Chat Чат
type Chat struct {
	// Channel Является каналом
	Channel bool `json:"channel"`

	// CreatedAt Дата и время создания чата (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// GroupTagIds Массив идентификаторов тегов, участников
	GroupTagIds []int32 `json:"group_tag_ids"`

	// Id Идентификатор созданного чата
	Id int32 `json:"id"`

	// LastMessageAt Дата и время создания последнего сообщения в чате (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	LastMessageAt time.Time `json:"last_message_at"`

	// MeetRoomUrl Ссылка на Видеочат
	MeetRoomUrl string `json:"meet_room_url"`

	// MemberIds Массив идентификаторов пользователей, участников
	MemberIds []int32 `json:"member_ids"`

	// Name Название
	Name string `json:"name"`

	// OwnerId Идентификатор пользователя, создавшего чат
	OwnerId int32 `json:"owner_id"`

	// Personal Является личным чатом
	Personal bool `json:"personal"`

	// Public Открытый доступ
	Public bool `json:"public"`
}

// ChatAvailability Доступность чатов для пользователя
type ChatAvailability string

// ChatCreateRequest Запрос на создание чата
type ChatCreateRequest struct {
	// Chat Собранный объект параметров создаваемого чата
	Chat struct {
		// Channel Является каналом
		Channel *bool `json:"channel,omitempty"`

		// GroupTagIds Массив идентификаторов тегов, которые станут участниками
		GroupTagIds *[]int32 `json:"group_tag_ids,omitempty"`

		// MemberIds Массив идентификаторов пользователей, которые станут участниками
		MemberIds *[]int32 `json:"member_ids,omitempty"`

		// Name Название
		Name string `json:"name"`

		// Public Открытый доступ
		Public *bool `json:"public,omitempty"`
	} `json:"chat"`
}

// ChatMemberRole Роль участника чата
type ChatMemberRole string

// ChatMemberRoleFilter Роль участника чата (с фильтром все)
type ChatMemberRoleFilter string

// ChatMemberWebhookPayload Структура исходящего вебхука об участниках чата
type ChatMemberWebhookPayload struct {
	// ChatId Идентификатор чата, в котором изменился состав участников
	ChatId int32 `json:"chat_id"`

	// CreatedAt Дата и время события (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// Event Тип события
	Event MemberEventType `json:"event"`

	// ThreadId Идентификатор треда
	ThreadId *int32 `json:"thread_id"`

	// Type Тип объекта
	Type ChatMemberWebhookPayloadType `json:"type"`

	// UserIds Массив идентификаторов пользователей, с которыми произошло событие
	UserIds []int32 `json:"user_ids"`

	// WebhookTimestamp Дата и время отправки вебхука (UTC+0) в формате UNIX
	WebhookTimestamp int32 `json:"webhook_timestamp"`
}

// ChatMemberWebhookPayloadType Тип объекта
type ChatMemberWebhookPayloadType string

// ChatUpdateRequest Запрос на обновление чата
type ChatUpdateRequest struct {
	// Chat Собранный объект параметров обновляемого чата
	Chat struct {
		// Name Название
		Name *string `json:"name,omitempty"`

		// Public Открытый доступ
		Public *bool `json:"public,omitempty"`
	} `json:"chat"`
}

// CompanyMemberWebhookPayload Структура исходящего вебхука об участниках пространства
type CompanyMemberWebhookPayload struct {
	// CreatedAt Дата и время события (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// Event Тип события
	Event UserEventType `json:"event"`

	// Type Тип объекта
	Type CompanyMemberWebhookPayloadType `json:"type"`

	// UserIds Массив идентификаторов пользователей, с которыми произошло событие
	UserIds []int32 `json:"user_ids"`

	// WebhookTimestamp Дата и время отправки вебхука (UTC+0) в формате UNIX
	WebhookTimestamp int32 `json:"webhook_timestamp"`
}

// CompanyMemberWebhookPayloadType Тип объекта
type CompanyMemberWebhookPayloadType string

// CustomProperty Дополнительное поле
type CustomProperty struct {
	// DataType Тип поля
	DataType CustomPropertyDataType `json:"data_type"`

	// Id Идентификатор поля
	Id int32 `json:"id"`

	// Name Название поля
	Name string `json:"name"`

	// Value Значение
	Value string `json:"value"`
}

// CustomPropertyDataType Тип данных дополнительного поля
type CustomPropertyDataType string

// CustomPropertyDefinition Определение дополнительного поля (без значения)
type CustomPropertyDefinition struct {
	// DataType Тип поля
	DataType CustomPropertyDataType `json:"data_type"`

	// Id Идентификатор поля
	Id int32 `json:"id"`

	// Name Название поля
	Name string `json:"name"`
}

// EmptyResponse При безошибочном выполнении запроса тело ответа отсутствует
type EmptyResponse = map[string]interface{}

// ExportRequest Запрос на экспорт сообщений
type ExportRequest struct {
	// ChatIds Массив идентификаторов чатов. Указывается, если нужно получить сообщения только некоторых чатов.
	ChatIds *[]int32 `json:"chat_ids,omitempty"`

	// EndAt Дата окончания для экспорта (ISO-8601, UTC+0) в формате YYYY-MM-DD
	EndAt openapi_types.Date `json:"end_at"`

	// SkipChatsFile Пропуск формирования файла со списком чатов (chats.json)
	SkipChatsFile *bool `json:"skip_chats_file,omitempty"`

	// StartAt Дата начала для экспорта (ISO-8601, UTC+0) в формате YYYY-MM-DD
	StartAt openapi_types.Date `json:"start_at"`

	// WebhookUrl Адрес, на который будет отправлен вебхук по завершению экспорта
	WebhookUrl string `json:"webhook_url"`
}

// File Файл
type File struct {
	// FileType Тип файла
	FileType FileType `json:"file_type"`

	// Height Высота изображения в пикселях
	Height *int32 `json:"height"`

	// Id Идентификатор файла
	Id int32 `json:"id"`

	// Key Путь к файлу
	Key string `json:"key"`

	// Name Название файла с расширением
	Name string `json:"name"`

	// Url Прямая ссылка на скачивание файла
	Url string `json:"url"`

	// Width Ширина изображения в пикселях
	Width *int32 `json:"width"`
}

// FileType Тип файла
type FileType string

// FileUploadRequest defines model for FileUploadRequest.
type FileUploadRequest struct {
	// Acl Параметр acl, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	Acl string `json:"acl"`

	// ContentDisposition Параметр Content-Disposition, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	ContentDisposition string `json:"contentDisposition"`

	// File Файл для загрузки
	File openapi_types.File `json:"file"`

	// Key Параметр key, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	Key string `json:"key"`

	// Policy Параметр policy, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	Policy string `json:"policy"`

	// XAmzAlgorithm Параметр x-amz-algorithm, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	XAmzAlgorithm string `json:"xAmzAlgorithm"`

	// XAmzCredential Параметр x-amz-credential, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	XAmzCredential string `json:"xAmzCredential"`

	// XAmzDate Параметр x-amz-date, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	XAmzDate string `json:"xAmzDate"`

	// XAmzSignature Параметр x-amz-signature, полученный в ответе на запрос [Получение подписи, ключа и других параметров](POST /uploads)
	XAmzSignature string `json:"xAmzSignature"`
}

// Forwarding Информация о пересланном сообщении
type Forwarding struct {
	// AuthorId Идентификатор пользователя, создавшего оригинальное сообщение
	AuthorId int32 `json:"author_id"`

	// OriginalChatId Идентификатор чата, в котором находится оригинальное сообщение
	OriginalChatId int32 `json:"original_chat_id"`

	// OriginalCreatedAt Дата и время создания оригинального сообщения (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	OriginalCreatedAt time.Time `json:"original_created_at"`

	// OriginalMessageId Идентификатор оригинального сообщения
	OriginalMessageId int32 `json:"original_message_id"`

	// OriginalThreadId Идентификатор треда, в котором находится оригинальное сообщение
	OriginalThreadId *int32 `json:"original_thread_id"`

	// OriginalThreadMessageId Идентификатор сообщения, к которому был создан тред, в котором находится оригинальное сообщение
	OriginalThreadMessageId *int32 `json:"original_thread_message_id"`

	// OriginalThreadParentChatId Идентификатор чата сообщения, к которому был создан тред, в котором находится оригинальное сообщение
	OriginalThreadParentChatId *int32 `json:"original_thread_parent_chat_id"`
}

// GroupTag Тег
type GroupTag struct {
	// Id Идентификатор тега
	Id int32 `json:"id"`

	// Name Название тега
	Name string `json:"name"`

	// UsersCount Количество сотрудников, которые имеют этот тег
	UsersCount int32 `json:"users_count"`
}

// GroupTagRequest Запрос на создание или редактирование тега
type GroupTagRequest struct {
	GroupTag struct {
		// Name Название тега
		Name string `json:"name"`
	} `json:"group_tag"`
}

// InviteStatus Статус приглашения пользователя
type InviteStatus string

// LinkPreview Данные для предпросмотра ссылки
type LinkPreview struct {
	// Description Описание
	Description string `json:"description"`

	// Image Изображение
	Image *struct {
		// Key Путь к изображению, полученный в результате [загрузки файла](POST /direct_url)
		Key string `json:"key"`

		// Name Название изображения (рекомендуется писать вместе с расширением)
		Name string `json:"name"`

		// Size Размер изображения в байтах
		Size int32 `json:"size"`
	} `json:"image,omitempty"`

	// ImageUrl Публичная ссылка на изображение (если вы хотите загрузить файл изображения в Пачку, то используйте параметр image)
	ImageUrl *string `json:"image_url,omitempty"`

	// Title Заголовок
	Title string `json:"title"`
}

// LinkPreviewsRequest Запрос на разворачивание ссылок
type LinkPreviewsRequest struct {
	// LinkPreviews `JSON` карта предпросмотров ссылок, где каждый ключ — `URL`, который был получен в исходящем вебхуке о новом сообщении.
	LinkPreviews map[string]LinkPreview `json:"link_previews"`
}

// LinkSharedWebhookPayload Структура исходящего вебхука о разворачивании ссылок
type LinkSharedWebhookPayload struct {
	// ChatId Идентификатор чата, в котором обнаружена ссылка
	ChatId int32 `json:"chat_id"`

	// CreatedAt Дата и время создания сообщения (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// Event Тип события
	Event LinkSharedWebhookPayloadEvent `json:"event"`

	// Links Массив обнаруженных ссылок на отслеживаемые домены
	Links []WebhookLink `json:"links"`

	// MessageId Идентификатор сообщения, содержащего ссылку
	MessageId int32 `json:"message_id"`

	// Type Тип объекта
	Type LinkSharedWebhookPayloadType `json:"type"`

	// WebhookTimestamp Дата и время отправки вебхука (UTC+0) в формате UNIX
	WebhookTimestamp int32 `json:"webhook_timestamp"`
}

// LinkSharedWebhookPayloadEvent Тип события
type LinkSharedWebhookPayloadEvent string

// LinkSharedWebhookPayloadType Тип объекта
type LinkSharedWebhookPayloadType string

// MemberEventType Тип события webhook для участников
type MemberEventType string

// Message Сообщение
type Message struct {
	// Buttons Массив строк, каждая из которых представлена массивом кнопок
	Buttons [][]Button `json:"buttons"`

	// ChatId Идентификатор чата, в котором находится сообщение
	ChatId int32 `json:"chat_id"`

	// Content Текст сообщения
	Content string `json:"content"`

	// CreatedAt Дата и время создания сообщения (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// DisplayAvatarUrl Ссылка на аватарку отправителя сообщения
	DisplayAvatarUrl *string `json:"display_avatar_url"`

	// DisplayName Полное имя отправителя сообщения
	DisplayName *string `json:"display_name"`

	// EntityId Идентификатор сущности, к которой относится сообщение (беседы/канала, треда или пользователя)
	EntityId int32 `json:"entity_id"`

	// EntityType Тип сущности, к которой относится сообщение
	EntityType MessageEntityType `json:"entity_type"`

	// Files Прикрепленные файлы
	Files []File `json:"files"`

	// Forwarding Информация о пересланном сообщении
	Forwarding *Forwarding `json:"forwarding"`

	// Id Идентификатор сообщения
	Id int32 `json:"id"`

	// ParentMessageId Идентификатор сообщения, к которому написан ответ
	ParentMessageId *int32 `json:"parent_message_id"`

	// Thread Тред сообщения
	Thread *Thread `json:"thread"`

	// Url Прямая ссылка на сообщение
	Url string `json:"url"`

	// UserId Идентификатор пользователя, создавшего сообщение
	UserId int32 `json:"user_id"`
}

// MessageCreateRequest Запрос на создание сообщения
type MessageCreateRequest struct {
	// Message Собранный объект параметров создаваемого сообщения
	Message struct {
		// Buttons Массив строк, каждая из которых представлена массивом кнопок. Максимум 100 кнопок у сообщения, до 8 кнопок в строке.
		Buttons *[][]Button `json:"buttons,omitempty"`

		// Content Текст сообщения
		Content string `json:"content"`

		// DisplayAvatarUrl Ссылка на специальную аватарку отправителя для этого сообщения. Использование этого поля возможно только с access_token бота.
		DisplayAvatarUrl *string `json:"display_avatar_url,omitempty"`

		// DisplayName Полное специальное имя отправителя для этого сообщения. Использование этого поля возможно только с access_token бота.
		DisplayName *string `json:"display_name,omitempty"`

		// EntityId Идентификатор сущности
		EntityId int32 `json:"entity_id"`

		// EntityType Тип сущности
		EntityType *MessageEntityType `json:"entity_type,omitempty"`

		// Files Прикрепляемые файлы
		Files *[]struct {
			// FileType Тип файла
			FileType MessageCreateRequestMessageFilesFileType `json:"file_type"`

			// Height Высота изображения в px (используется в случае, если file_type указан как image)
			Height *int32 `json:"height,omitempty"`

			// Key Путь к файлу, полученный в результате [загрузки файла](POST /direct_url)
			Key string `json:"key"`

			// Name Название файла, которое вы хотите отображать пользователю (рекомендуется писать вместе с расширением)
			Name string `json:"name"`

			// Size Размер файла в байтах, отображаемый пользователю
			Size int32 `json:"size"`

			// Width Ширина изображения в px (используется в случае, если file_type указан как image)
			Width *int32 `json:"width,omitempty"`
		} `json:"files,omitempty"`

		// LinkPreview Отображение предпросмотра первой найденной ссылки в тексте сообщения
		LinkPreview *bool `json:"link_preview,omitempty"`

		// ParentMessageId Идентификатор сообщения. Указывается в случае, если вы отправляете ответ на другое сообщение.
		ParentMessageId *int32 `json:"parent_message_id,omitempty"`

		// SkipInviteMentions Пропуск добавления упоминаемых пользователей в тред. Работает только при отправке сообщения в тред.
		SkipInviteMentions *bool `json:"skip_invite_mentions,omitempty"`
	} `json:"message"`
}

// MessageCreateRequestMessageFilesFileType Тип файла
type MessageCreateRequestMessageFilesFileType string

// MessageEntityType Тип сущности для сообщений
type MessageEntityType string

// MessageUpdateRequest Запрос на редактирование сообщения
type MessageUpdateRequest struct {
	// Message Собранный объект параметров редактируемого сообщения
	Message struct {
		// Buttons Массив строк, каждая из которых представлена массивом кнопок. Максимум 100 кнопок у сообщения, до 8 кнопок в строке. Для удаления кнопок пришлите пустой массив.
		Buttons *[][]Button `json:"buttons,omitempty"`

		// Content Текст сообщения
		Content *string `json:"content,omitempty"`

		// DisplayAvatarUrl Ссылка на специальную аватарку отправителя для этого сообщения. Использование этого поля возможно только с access_token бота.
		DisplayAvatarUrl *string `json:"display_avatar_url,omitempty"`

		// DisplayName Полное специальное имя отправителя для этого сообщения. Использование этого поля возможно только с access_token бота.
		DisplayName *string `json:"display_name,omitempty"`

		// Files Прикрепляемые файлы
		Files *[]struct {
			// FileType Тип файла: файл (file), изображение (image)
			FileType *string `json:"file_type,omitempty"`

			// Height Высота изображения в px (используется в случае, если file_type указан как image)
			Height *int32 `json:"height,omitempty"`

			// Key Путь к файлу, полученный в результате [загрузки файла](POST /direct_url)
			Key string `json:"key"`

			// Name Название файла, которое вы хотите отображать пользователю (рекомендуется писать вместе с расширением)
			Name string `json:"name"`

			// Size Размер файла в байтах, отображаемый пользователю
			Size *int32 `json:"size,omitempty"`

			// Width Ширина изображения в px (используется в случае, если file_type указан как image)
			Width *int32 `json:"width,omitempty"`
		} `json:"files,omitempty"`
	} `json:"message"`
}

// MessageWebhookPayload Структура исходящего вебхука о сообщении
type MessageWebhookPayload struct {
	// ChatId Идентификатор чата, в котором находится сообщение
	ChatId int32 `json:"chat_id"`

	// Content Текст сообщения
	Content string `json:"content"`

	// CreatedAt Дата и время создания сообщения (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// EntityId Идентификатор сущности, к которой относится сообщение
	EntityId int32 `json:"entity_id"`

	// EntityType Тип сущности, к которой относится сообщение
	EntityType MessageEntityType `json:"entity_type"`

	// Event Тип события
	Event WebhookEventType `json:"event"`

	// Id Идентификатор сообщения
	Id int32 `json:"id"`

	// ParentMessageId Идентификатор сообщения, к которому написан ответ
	ParentMessageId *int32 `json:"parent_message_id"`

	// Thread Объект с параметрами треда
	Thread *WebhookMessageThread `json:"thread"`

	// Type Тип объекта
	Type MessageWebhookPayloadType `json:"type"`

	// Url Прямая ссылка на сообщение
	Url string `json:"url"`

	// UserId Идентификатор отправителя сообщения
	UserId int32 `json:"user_id"`

	// WebhookTimestamp Дата и время отправки вебхука (UTC+0) в формате UNIX
	WebhookTimestamp int32 `json:"webhook_timestamp"`
}

// MessageWebhookPayloadType Тип объекта
type MessageWebhookPayloadType string

// OAuthError Ошибка OAuth авторизации (используется для 401 и 403)
type OAuthError struct {
	// Error Код ошибки
	Error string `json:"error"`

	// ErrorDescription Описание ошибки
	ErrorDescription string `json:"error_description"`
}

// OAuthScope Скоуп доступа OAuth токена
type OAuthScope string

// OpenViewRequest Запрос на открытие представления
type OpenViewRequest struct {
	// CallbackId Необязательный идентификатор для распознавания этого представления, который будет отправлен в ваше приложение при отправке пользователем заполненной формы. Используйте это поле, например, для понимания, какую форму должен был заполнить пользователь.
	CallbackId *string `json:"callback_id,omitempty"`

	// PrivateMetadata Необязательная строка, которая будет отправлена в ваше приложение при отправке пользователем заполненной формы. Используйте это поле, например, для передачи в формате `JSON` какой то дополнительной информации вместе с заполненной пользователем формой.
	PrivateMetadata *string `json:"private_metadata,omitempty"`

	// TriggerId Уникальный идентификатор события (полученный, например, в исходящем вебхуке о нажатии кнопки)
	TriggerId string `json:"trigger_id"`

	// Type Способ открытия представления
	Type OpenViewRequestType `json:"type"`

	// View Собранный объект представления
	View struct {
		// Blocks Массив блоков представления
		Blocks []ViewBlockUnion `json:"blocks"`

		// CloseText Текст кнопки закрытия представления
		CloseText *string `json:"close_text,omitempty"`

		// SubmitText Текст кнопки отправки формы
		SubmitText *string `json:"submit_text,omitempty"`

		// Title Заголовок представления
		Title string `json:"title"`
	} `json:"view"`
}

// OpenViewRequestType Способ открытия представления
type OpenViewRequestType string

// PaginationMeta Метаданные пагинации
type PaginationMeta struct {
	// Paginate Вспомогательная информация
	Paginate *struct {
		// NextPage Курсор пагинации следующей страницы
		NextPage *string `json:"next_page,omitempty"`
	} `json:"paginate,omitempty"`
}

// Reaction Реакция на сообщение
type Reaction struct {
	// Code Emoji символ реакции
	Code string `json:"code"`

	// CreatedAt Дата и время добавления реакции (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// Name Название emoji реакции
	Name *string `json:"name,omitempty"`

	// UserId Идентификатор пользователя, который добавил реакцию
	UserId int32 `json:"user_id"`
}

// ReactionEventType Тип события webhook для реакций
type ReactionEventType string

// ReactionRequest Запрос на добавление реакции
type ReactionRequest struct {
	// Code Emoji символ реакции
	Code string `json:"code"`

	// Name Текстовое имя эмодзи (используется для кастомных эмодзи)
	Name *string `json:"name,omitempty"`
}

// ReactionWebhookPayload Структура исходящего вебхука о реакции
type ReactionWebhookPayload struct {
	// Code Emoji символ реакции
	Code string `json:"code"`

	// CreatedAt Дата и время создания сообщения (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// Event Тип события
	Event ReactionEventType `json:"event"`

	// MessageId Идентификатор сообщения, к которому относится реакция
	MessageId int32 `json:"message_id"`

	// Name Название реакции
	Name string `json:"name"`

	// Type Тип объекта
	Type ReactionWebhookPayloadType `json:"type"`

	// UserId Идентификатор пользователя, который добавил или удалил реакцию
	UserId int32 `json:"user_id"`

	// WebhookTimestamp Дата и время отправки вебхука (UTC+0) в формате UNIX
	WebhookTimestamp int32 `json:"webhook_timestamp"`
}

// ReactionWebhookPayloadType Тип объекта
type ReactionWebhookPayloadType string

// SearchEntityType Тип сущности для поиска
type SearchEntityType string

// SortOrder Порядок сортировки
type SortOrder string

// StatusUpdateRequest Запрос на установку статуса
type StatusUpdateRequest struct {
	Status struct {
		// Emoji Emoji символ статуса
		Emoji string `json:"emoji"`

		// ExpiresAt Срок жизни статуса (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
		ExpiresAt *time.Time `json:"expires_at,omitempty"`

		// Title Текст статуса
		Title string `json:"title"`
	} `json:"status"`
}

// TagNamesFilter Массив названий тегов
type TagNamesFilter = []string

// Task Напоминание
type Task struct {
	// AllDay Напоминание на весь день (без указания времени)
	AllDay bool `json:"all_day"`

	// Content Описание
	Content string `json:"content"`

	// CreatedAt Дата и время создания напоминания (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// CustomProperties Дополнительные поля напоминания
	CustomProperties []CustomProperty `json:"custom_properties"`

	// DueAt Срок выполнения напоминания (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	DueAt *time.Time `json:"due_at"`

	// Id Идентификатор напоминания
	Id int32 `json:"id"`

	// Kind Тип
	Kind TaskKind `json:"kind"`

	// PerformerIds Массив идентификаторов пользователей, привязанных к напоминанию как «ответственные»
	PerformerIds []int32 `json:"performer_ids"`

	// Priority Приоритет
	Priority int32 `json:"priority"`

	// Status Статус напоминания
	Status TaskStatus `json:"status"`

	// UserId Идентификатор пользователя-создателя напоминания
	UserId int32 `json:"user_id"`
}

// TaskStatus Статус напоминания
type TaskStatus string

// TaskCreateRequest Запрос на создание напоминания
type TaskCreateRequest struct {
	// Task Собранный объект параметров создаваемого напоминания
	Task struct {
		// AllDay Напоминание на весь день (без указания времени)
		AllDay *bool `json:"all_day,omitempty"`

		// Content Описание (по умолчанию — название типа)
		Content *string `json:"content,omitempty"`

		// CustomProperties Задаваемые дополнительные поля
		CustomProperties *[]struct {
			// Id Идентификатор поля
			Id int32 `json:"id"`

			// Value Устанавливаемое значение
			Value string `json:"value"`
		} `json:"custom_properties,omitempty"`

		// DueAt Срок выполнения напоминания (ISO-8601) в формате YYYY-MM-DDThh:mm:ss.sssTZD. Если указано время 23:59:59.000, то напоминание будет создано на весь день (без указания времени).
		DueAt *time.Time `json:"due_at,omitempty"`

		// Kind Тип
		Kind TaskKind `json:"kind"`

		// PerformerIds Массив идентификаторов пользователей, привязываемых к напоминанию как «ответственные» (по умолчанию ответственным назначается вы)
		PerformerIds *[]int32 `json:"performer_ids,omitempty"`

		// Priority Приоритет: 1, 2 (важно) или 3 (очень важно).
		Priority *int32 `json:"priority,omitempty"`
	} `json:"task"`
}

// TaskKind Тип задачи
type TaskKind string

// TaskUpdateRequest Запрос на обновление напоминания
type TaskUpdateRequest struct {
	// Task Собранный объект параметров обновляемого напоминания
	Task struct {
		// AllDay Напоминание на весь день (без указания времени)
		AllDay *bool `json:"all_day,omitempty"`

		// Content Описание
		Content *string `json:"content,omitempty"`

		// CustomProperties Задаваемые дополнительные поля
		CustomProperties *[]struct {
			// Id Идентификатор поля
			Id int32 `json:"id"`

			// Value Устанавливаемое значение
			Value string `json:"value"`
		} `json:"custom_properties,omitempty"`

		// DoneAt Дата и время выполнения напоминания (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
		DoneAt *time.Time `json:"done_at,omitempty"`

		// DueAt Срок выполнения напоминания (ISO-8601) в формате YYYY-MM-DDThh:mm:ss.sssTZD. Если указано время 23:59:59.000, то напоминание будет создано на весь день (без указания времени).
		DueAt *time.Time `json:"due_at,omitempty"`

		// Kind Тип
		Kind *TaskKind `json:"kind,omitempty"`

		// PerformerIds Массив идентификаторов пользователей, привязываемых к напоминанию как «ответственные»
		PerformerIds *[]int32 `json:"performer_ids,omitempty"`

		// Priority Приоритет: 1, 2 (важно) или 3 (очень важно).
		Priority *int32 `json:"priority,omitempty"`

		// Status Статус
		Status *TaskUpdateRequestTaskStatus `json:"status,omitempty"`
	} `json:"task"`
}

// TaskUpdateRequestTaskStatus Статус
type TaskUpdateRequestTaskStatus string

// Thread Тред
type Thread struct {
	// ChatId Идентификатор чата треда (используется для отправки [новых комментариев](POST /messages) в тред и получения [списка комментариев](GET /messages))
	ChatId int64 `json:"chat_id"`

	// Id Идентификатор созданного треда (используется для отправки [новых комментариев](POST /messages) в тред)
	Id int64 `json:"id"`

	// MessageChatId Идентификатор чата сообщения
	MessageChatId int64 `json:"message_chat_id"`

	// MessageId Идентификатор сообщения, к которому был создан тред
	MessageId int64 `json:"message_id"`

	// UpdatedAt Дата и время обновления треда (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	UpdatedAt time.Time `json:"updated_at"`
}

// UpdateMemberRoleRequest Запрос на изменение роли участника
type UpdateMemberRoleRequest struct {
	// Role Роль
	Role ChatMemberRole `json:"role"`
}

// UploadParams Параметры для загрузки файла
type UploadParams struct {
	// ContentDisposition Используемый заголовок (в данном запросе — attachment)
	ContentDisposition string `json:"Content-Disposition"`

	// Acl Уровень безопасности (в данном запросе — private)
	Acl string `json:"acl"`

	// DirectUrl Адрес для загрузки файла
	DirectUrl string `json:"direct_url"`

	// Key Уникальный ключ для загрузки файла
	Key string `json:"key"`

	// Policy Уникальная policy для загрузки файла
	Policy string `json:"policy"`

	// XAmzAlgorithm Используемый алгоритм (в данном запросе — AWS4-HMAC-SHA256)
	XAmzAlgorithm string `json:"x-amz-algorithm"`

	// XAmzCredential x-amz-credential для загрузки файла
	XAmzCredential string `json:"x-amz-credential"`

	// XAmzDate Уникальный x-amz-date для загрузки файла
	XAmzDate string `json:"x-amz-date"`

	// XAmzSignature Уникальная подпись для загрузки файла
	XAmzSignature string `json:"x-amz-signature"`
}

// User Сотрудник
type User struct {
	// Bot Является ботом
	Bot bool `json:"bot"`

	// CreatedAt Дата создания (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// CustomProperties Дополнительные поля сотрудника
	CustomProperties []CustomProperty `json:"custom_properties"`

	// Department Департамент
	Department string `json:"department"`

	// Email Электронная почта
	Email string `json:"email"`

	// FirstName Имя
	FirstName string `json:"first_name"`

	// Id Идентификатор пользователя
	Id int32 `json:"id"`

	// ImageUrl Ссылка на скачивание аватарки пользователя
	ImageUrl *string `json:"image_url"`

	// InviteStatus Статус приглашения
	InviteStatus InviteStatus `json:"invite_status"`

	// LastActivityAt Дата последней активности пользователя (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	LastActivityAt time.Time `json:"last_activity_at"`

	// LastName Фамилия
	LastName string `json:"last_name"`

	// ListTags Массив тегов, привязанных к сотруднику
	ListTags []string `json:"list_tags"`

	// Nickname Имя пользователя
	Nickname string `json:"nickname"`

	// PhoneNumber Телефон
	PhoneNumber string `json:"phone_number"`

	// Role Уровень доступа
	Role UserRole `json:"role"`

	// Sso Использует ли пользователь SSO
	Sso bool `json:"sso"`

	// Suspended Деактивация пользователя
	Suspended bool `json:"suspended"`

	// TimeZone Часовой пояс пользователя
	TimeZone string `json:"time_zone"`

	// Title Должность
	Title string `json:"title"`

	// UserStatus Статус
	UserStatus *UserStatus `json:"user_status"`
}

// UserCreateRequest Запрос на создание сотрудника
type UserCreateRequest struct {
	// SkipEmailNotify Пропуск этапа отправки приглашения сотруднику. Сотруднику не будет отправлено письмо на электронную почту с приглашением создать аккаунт. Полезно при предварительном создании аккаунтов перед входом через SSO.
	SkipEmailNotify *bool `json:"skip_email_notify,omitempty"`
	User            struct {
		// CustomProperties Задаваемые дополнительные поля
		CustomProperties *[]struct {
			// Id Идентификатор поля
			Id int32 `json:"id"`

			// Value Устанавливаемое значение
			Value string `json:"value"`
		} `json:"custom_properties,omitempty"`

		// Department Департамент
		Department *string `json:"department,omitempty"`

		// Email Электронная почта
		Email string `json:"email"`

		// FirstName Имя
		FirstName *string `json:"first_name,omitempty"`

		// LastName Фамилия
		LastName *string `json:"last_name,omitempty"`

		// ListTags Массив тегов, привязываемых к сотруднику
		ListTags *[]string `json:"list_tags,omitempty"`

		// Nickname Имя пользователя
		Nickname *string `json:"nickname,omitempty"`

		// PhoneNumber Телефон
		PhoneNumber *string `json:"phone_number,omitempty"`

		// Role Уровень доступа
		Role *UserRole `json:"role,omitempty"`

		// Suspended Деактивация пользователя
		Suspended *bool `json:"suspended,omitempty"`

		// Title Должность
		Title *string `json:"title,omitempty"`
	} `json:"user"`
}

// UserEventType Тип события webhook для пользователей
type UserEventType string

// UserRole Роль пользователя в системе
type UserRole string

// UserStatus Статус пользователя
type UserStatus struct {
	// Emoji Emoji символ статуса
	Emoji string `json:"emoji"`

	// ExpiresAt Срок жизни статуса (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	ExpiresAt *time.Time `json:"expires_at"`

	// Title Текст статуса
	Title string `json:"title"`
}

// UserUpdateRequest Запрос на редактирование сотрудника
type UserUpdateRequest struct {
	// User Собранный объект параметров редактируемого сотрудника
	User struct {
		// CustomProperties Задаваемые дополнительные поля
		CustomProperties *[]struct {
			// Id Идентификатор поля
			Id int32 `json:"id"`

			// Value Устанавливаемое значение
			Value string `json:"value"`
		} `json:"custom_properties,omitempty"`

		// Department Департамент
		Department *string `json:"department,omitempty"`

		// Email Электронная почта
		Email *string `json:"email,omitempty"`

		// FirstName Имя
		FirstName *string `json:"first_name,omitempty"`

		// LastName Фамилия
		LastName *string `json:"last_name,omitempty"`

		// ListTags Массив тегов, привязываемых к сотруднику
		ListTags *[]string `json:"list_tags,omitempty"`

		// Nickname Имя пользователя
		Nickname *string `json:"nickname,omitempty"`

		// PhoneNumber Телефон
		PhoneNumber *string `json:"phone_number,omitempty"`

		// Role Уровень доступа
		Role *UserUpdateRequestUserRole `json:"role,omitempty"`

		// Suspended Деактивация пользователя
		Suspended *bool `json:"suspended,omitempty"`

		// Title Должность
		Title *string `json:"title,omitempty"`
	} `json:"user"`
}

// UserUpdateRequestUserRole Уровень доступа
type UserUpdateRequestUserRole string

// ValidationErrorCode Коды ошибок валидации
type ValidationErrorCode string

// ViewBlockCheckbox Блок checkbox — чекбоксы
type ViewBlockCheckbox struct {
	// Hint Подсказка, которая отображается под группой чекбоксов серым цветом
	Hint *string `json:"hint,omitempty"`

	// Label Подпись к группе чекбоксов
	Label string `json:"label"`

	// Name Название, которое будет передано в ваше приложение как ключ указанного пользователем выбора
	Name string `json:"name"`

	// Options Массив чекбоксов
	Options *[]ViewBlockCheckboxOption `json:"options,omitempty"`

	// Required Обязательность
	Required *bool `json:"required,omitempty"`

	// Type Тип блока
	Type ViewBlockCheckboxType `json:"type"`
}

// ViewBlockCheckboxType Тип блока
type ViewBlockCheckboxType string

// ViewBlockCheckboxOption defines model for ViewBlockCheckboxOption.
type ViewBlockCheckboxOption struct {
	// Checked Изначально выбранный пункт
	Checked *bool `json:"checked,omitempty"`

	// Description Пояснение, которое будет указано серым цветом в этом пункте под отображаемым текстом
	Description *string `json:"description,omitempty"`

	// Text Отображаемый текст
	Text string `json:"text"`

	// Value Уникальное строковое значение, которое будет передано в ваше приложение при выборе этого пункта
	Value string `json:"value"`
}

// ViewBlockDate Блок date — выбор даты
type ViewBlockDate struct {
	// Hint Подсказка, которая отображается под полем серым цветом
	Hint *string `json:"hint,omitempty"`

	// InitialDate Начальное значение в поле в формате YYYY-MM-DD
	InitialDate *openapi_types.Date `json:"initial_date,omitempty"`

	// Label Подпись к полю
	Label string `json:"label"`

	// Name Название, которое будет передано в ваше приложение как ключ указанного пользователем значения
	Name string `json:"name"`

	// Required Обязательность
	Required *bool `json:"required,omitempty"`

	// Type Тип блока
	Type ViewBlockDateType `json:"type"`
}

// ViewBlockDateType Тип блока
type ViewBlockDateType string

// ViewBlockDivider Блок divider — разделитель
type ViewBlockDivider struct {
	// Type Тип блока
	Type ViewBlockDividerType `json:"type"`
}

// ViewBlockDividerType Тип блока
type ViewBlockDividerType string

// ViewBlockFileInput Блок file_input — загрузка файлов
type ViewBlockFileInput struct {
	// Filetypes Массив допустимых расширений файлов, указанные в виде строк (например, ["png","jpg","gif"]). Если это поле не указано, все расширения файлов будут приняты.
	Filetypes *[]string `json:"filetypes,omitempty"`

	// Hint Подсказка, которая отображается под полем серым цветом
	Hint *string `json:"hint,omitempty"`

	// Label Подпись к полю
	Label string `json:"label"`

	// MaxFiles Максимальное количество файлов, которое может загрузить пользователь в это поле.
	MaxFiles *int32 `json:"max_files,omitempty"`

	// Name Название, которое будет передано в ваше приложение как ключ указанного пользователем значения
	Name string `json:"name"`

	// Required Обязательность
	Required *bool `json:"required,omitempty"`

	// Type Тип блока
	Type ViewBlockFileInputType `json:"type"`
}

// ViewBlockFileInputType Тип блока
type ViewBlockFileInputType string

// ViewBlockHeader Блок header — заголовок
type ViewBlockHeader struct {
	// Text Текст заголовка
	Text string `json:"text"`

	// Type Тип блока
	Type ViewBlockHeaderType `json:"type"`
}

// ViewBlockHeaderType Тип блока
type ViewBlockHeaderType string

// ViewBlockInput Блок input — текстовое поле ввода
type ViewBlockInput struct {
	// Hint Подсказка, которая отображается под полем серым цветом
	Hint *string `json:"hint,omitempty"`

	// InitialValue Начальное значение в поле
	InitialValue *string `json:"initial_value,omitempty"`

	// Label Подпись к полю
	Label string `json:"label"`

	// MaxLength Максимальная длина текста, который должен написать пользователь. Если пользователь напишет больше, он получит ошибку.
	MaxLength *int32 `json:"max_length,omitempty"`

	// MinLength Минимальная длина текста, который должен написать пользователь. Если пользователь напишет меньше, он получит ошибку.
	MinLength *int32 `json:"min_length,omitempty"`

	// Multiline Многострочное поле
	Multiline *bool `json:"multiline,omitempty"`

	// Name Название, которое будет передано в ваше приложение как ключ указанного пользователем значения
	Name string `json:"name"`

	// Placeholder Подсказка внутри поля ввода, пока оно пустое
	Placeholder *string `json:"placeholder,omitempty"`

	// Required Обязательность
	Required *bool `json:"required,omitempty"`

	// Type Тип блока
	Type ViewBlockInputType `json:"type"`
}

// ViewBlockInputType Тип блока
type ViewBlockInputType string

// ViewBlockMarkdown Блок markdown — форматированный текст
type ViewBlockMarkdown struct {
	// Text Текст
	Text string `json:"text"`

	// Type Тип блока
	Type ViewBlockMarkdownType `json:"type"`
}

// ViewBlockMarkdownType Тип блока
type ViewBlockMarkdownType string

// ViewBlockPlainText Блок plain_text — обычный текст
type ViewBlockPlainText struct {
	// Text Текст
	Text string `json:"text"`

	// Type Тип блока
	Type ViewBlockPlainTextType `json:"type"`
}

// ViewBlockPlainTextType Тип блока
type ViewBlockPlainTextType string

// ViewBlockRadio Блок radio — радиокнопки
type ViewBlockRadio struct {
	// Hint Подсказка, которая отображается под группой радиокнопок серым цветом
	Hint *string `json:"hint,omitempty"`

	// Label Подпись к группе радиокнопок
	Label string `json:"label"`

	// Name Название, которое будет передано в ваше приложение как ключ указанного пользователем выбора
	Name string `json:"name"`

	// Options Массив радиокнопок
	Options *[]ViewBlockSelectableOption `json:"options,omitempty"`

	// Required Обязательность
	Required *bool `json:"required,omitempty"`

	// Type Тип блока
	Type ViewBlockRadioType `json:"type"`
}

// ViewBlockRadioType Тип блока
type ViewBlockRadioType string

// ViewBlockSelect Блок select — выпадающий список
type ViewBlockSelect struct {
	// Hint Подсказка, которая отображается под выпадающим списком серым цветом
	Hint *string `json:"hint,omitempty"`

	// Label Подпись к выпадающему списку
	Label string `json:"label"`

	// Name Название, которое будет передано в ваше приложение как ключ указанного пользователем выбора
	Name string `json:"name"`

	// Options Массив доступных пунктов в выпадающем списке
	Options *[]ViewBlockSelectableOption `json:"options,omitempty"`

	// Required Обязательность
	Required *bool `json:"required,omitempty"`

	// Type Тип блока
	Type ViewBlockSelectType `json:"type"`
}

// ViewBlockSelectType Тип блока
type ViewBlockSelectType string

// ViewBlockSelectableOption Опция для блоков select, radio и checkbox
type ViewBlockSelectableOption struct {
	// Description Пояснение, которое будет указано серым цветом в этом пункте под отображаемым текстом
	Description *string `json:"description,omitempty"`

	// Selected Изначально выбранный пункт. Только один пункт может быть выбран.
	Selected *bool `json:"selected,omitempty"`

	// Text Отображаемый текст
	Text string `json:"text"`

	// Value Уникальное строковое значение, которое будет передано в ваше приложение при выборе этого пункта
	Value string `json:"value"`
}

// ViewBlockTime Блок time — выбор времени
type ViewBlockTime struct {
	// Hint Подсказка, которая отображается под полем серым цветом
	Hint *string `json:"hint,omitempty"`

	// InitialTime Начальное значение в поле в формате HH:mm
	InitialTime *string `json:"initial_time,omitempty"`

	// Label Подпись к полю
	Label string `json:"label"`

	// Name Название, которое будет передано в ваше приложение как ключ указанного пользователем значения
	Name string `json:"name"`

	// Required Обязательность
	Required *bool `json:"required,omitempty"`

	// Type Тип блока
	Type ViewBlockTimeType `json:"type"`
}

// ViewBlockTimeType Тип блока
type ViewBlockTimeType string

// ViewBlockUnion Union-тип для всех возможных блоков представления
type ViewBlockUnion struct {
	union json.RawMessage
}

// WebhookEvent Событие исходящего вебхука
type WebhookEvent struct {
	// CreatedAt Дата и время создания события (ISO-8601, UTC+0) в формате YYYY-MM-DDThh:mm:ss.sssZ
	CreatedAt time.Time `json:"created_at"`

	// EventType Тип события
	EventType string `json:"event_type"`

	// Id Идентификатор события
	Id string `json:"id"`

	// Payload Объект вебхука
	Payload WebhookPayloadUnion `json:"payload"`
}

// WebhookEventType Тип события webhook
type WebhookEventType string

// WebhookLink Объект ссылки в вебхуке разворачивания ссылок
type WebhookLink struct {
	// Domain Домен ссылки
	Domain string `json:"domain"`

	// Url URL ссылки
	Url string `json:"url"`
}

// WebhookMessageThread Объект треда в вебхуке сообщения
type WebhookMessageThread struct {
	// MessageChatId Идентификатор чата сообщения, к которому был создан тред
	MessageChatId int32 `json:"message_chat_id"`

	// MessageId Идентификатор сообщения, к которому был создан тред
	MessageId int32 `json:"message_id"`
}

// WebhookPayloadUnion Объединение всех типов payload вебхуков
type WebhookPayloadUnion struct {
	union json.RawMessage
}

// SecurityOperationsGetAuditEventsParams defines parameters for SecurityOperationsGetAuditEvents.
type SecurityOperationsGetAuditEventsParams struct {
	// StartTime Начальная метка времени (включительно)
	StartTime time.Time `form:"start_time" json:"start_time"`

	// EndTime Конечная метка времени (исключительно)
	EndTime time.Time `form:"end_time" json:"end_time"`

	// EventKey Фильтр по конкретному типу события
	EventKey *AuditEventKey `form:"event_key,omitempty" json:"event_key,omitempty"`

	// ActorId Идентификатор пользователя, выполнившего действие
	ActorId *int32 `form:"actor_id,omitempty" json:"actor_id,omitempty"`

	// ActorType Тип актора
	ActorType *string `form:"actor_type,omitempty" json:"actor_type,omitempty"`

	// EntityId Идентификатор затронутой сущности
	EntityId *int32 `form:"entity_id,omitempty" json:"entity_id,omitempty"`

	// EntityType Тип сущности
	EntityType *string `form:"entity_type,omitempty" json:"entity_type,omitempty"`

	// Limit Количество записей для возврата
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации из meta.paginate.next_page
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ChatOperationsListChatsParams defines parameters for ChatOperationsListChats.
type ChatOperationsListChatsParams struct {
	// SortField Составной параметр сортировки сущностей выборки. На данный момент сортировка доступна по полям `id` (идентификатор чата) и `last_message_at` (дата и время создания последнего сообщения).
	SortField *SortOrder `form:"sort[{field}],omitempty" json:"sort[{field}],omitempty"`

	// Availability Параметр, который отвечает за доступность и выборку чатов для пользователя
	Availability *ChatAvailability `form:"availability,omitempty" json:"availability,omitempty"`

	// LastMessageAtAfter Фильтрация по времени создания последнего сообщения. Будут возвращены те чаты, время последнего созданного сообщения в которых не раньше чем указанное (в формате YYYY-MM-DDThh:mm:ss.sssZ).
	LastMessageAtAfter *time.Time `form:"last_message_at_after,omitempty" json:"last_message_at_after,omitempty"`

	// LastMessageAtBefore Фильтрация по времени создания последнего сообщения. Будут возвращены те чаты, время последнего созданного сообщения в которых не позже чем указанное (в формате YYYY-MM-DDThh:mm:ss.sssZ).
	LastMessageAtBefore *time.Time `form:"last_message_at_before,omitempty" json:"last_message_at_before,omitempty"`

	// Personal Фильтрация по личным и групповым чатам. Если параметр не указан, возвращаются любые чаты.
	Personal *bool `form:"personal,omitempty" json:"personal,omitempty"`

	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из meta.paginate.next_page)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ChatMemberOperationsListMembersParams defines parameters for ChatMemberOperationsListMembers.
type ChatMemberOperationsListMembersParams struct {
	// Role Роль в чате
	Role *ChatMemberRoleFilter `form:"role,omitempty" json:"role,omitempty"`

	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из meta.paginate.next_page)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// CommonOperationsListPropertiesParams defines parameters for CommonOperationsListProperties.
type CommonOperationsListPropertiesParams struct {
	// EntityType Тип сущности
	EntityType SearchEntityType `form:"entity_type" json:"entity_type"`
}

// GroupTagOperationsListTagsParams defines parameters for GroupTagOperationsListTags.
type GroupTagOperationsListTagsParams struct {
	// Names Массив названий тегов, по которым вы хотите отфильтровать список
	Names *TagNamesFilter `form:"names,omitempty" json:"names,omitempty"`

	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из `meta.paginate.next_page`)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// GroupTagOperationsGetTagUsersParams defines parameters for GroupTagOperationsGetTagUsers.
type GroupTagOperationsGetTagUsersParams struct {
	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из `meta.paginate.next_page`)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ChatMessageOperationsListChatMessagesParams defines parameters for ChatMessageOperationsListChatMessages.
type ChatMessageOperationsListChatMessagesParams struct {
	// ChatId Идентификатор чата (беседа, канал, диалог или чат треда)
	ChatId int32 `form:"chat_id" json:"chat_id"`

	// SortField Составной параметр сортировки сущностей выборки. На данный момент сортировка доступна только по полю `id` (идентификатор сообщения).
	SortField *SortOrder `form:"sort[{field}],omitempty" json:"sort[{field}],omitempty"`

	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из `meta.paginate.next_page`)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ReactionOperationsRemoveReactionParams defines parameters for ReactionOperationsRemoveReaction.
type ReactionOperationsRemoveReactionParams struct {
	// Code Emoji символ реакции
	Code string `form:"code" json:"code"`

	// Name Текстовое имя эмодзи (используется для кастомных эмодзи)
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// ReactionOperationsListReactionsParams defines parameters for ReactionOperationsListReactions.
type ReactionOperationsListReactionsParams struct {
	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из `meta.paginate.next_page`)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ReadMemberOperationsListReadMembersParams defines parameters for ReadMemberOperationsListReadMembers.
type ReadMemberOperationsListReadMembersParams struct {
	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из `meta.paginate.next_page`)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// TaskOperationsListTasksParams defines parameters for TaskOperationsListTasks.
type TaskOperationsListTasksParams struct {
	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из `meta.paginate.next_page`)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// UserOperationsListUsersParams defines parameters for UserOperationsListUsers.
type UserOperationsListUsersParams struct {
	// Query Поисковая фраза для фильтрации результатов. Поиск работает по полям: `first_name` (имя), `last_name` (фамилия), `email` (электронная почта), `phone_number` (телефон) и `nickname` (никнейм).
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из `meta.paginate.next_page`)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// BotOperationsGetWebhookEventsParams defines parameters for BotOperationsGetWebhookEvents.
type BotOperationsGetWebhookEventsParams struct {
	// Limit Количество возвращаемых сущностей за один запрос
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Курсор для пагинации (из meta.paginate.next_page)
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// BotOperationsUpdateBotJSONRequestBody defines body for BotOperationsUpdateBot for application/json ContentType.
type BotOperationsUpdateBotJSONRequestBody = BotUpdateRequest

// ChatOperationsCreateChatJSONRequestBody defines body for ChatOperationsCreateChat for application/json ContentType.
type ChatOperationsCreateChatJSONRequestBody = ChatCreateRequest

// ExportOperationsRequestExportJSONRequestBody defines body for ExportOperationsRequestExport for application/json ContentType.
type ExportOperationsRequestExportJSONRequestBody = ExportRequest

// ChatOperationsUpdateChatJSONRequestBody defines body for ChatOperationsUpdateChat for application/json ContentType.
type ChatOperationsUpdateChatJSONRequestBody = ChatUpdateRequest

// ChatMemberOperationsAddTagsJSONRequestBody defines body for ChatMemberOperationsAddTags for application/json ContentType.
type ChatMemberOperationsAddTagsJSONRequestBody = AddTagsRequest

// ChatMemberOperationsAddMembersJSONRequestBody defines body for ChatMemberOperationsAddMembers for application/json ContentType.
type ChatMemberOperationsAddMembersJSONRequestBody = AddMembersRequest

// ChatMemberOperationsUpdateMemberRoleJSONRequestBody defines body for ChatMemberOperationsUpdateMemberRole for application/json ContentType.
type ChatMemberOperationsUpdateMemberRoleJSONRequestBody = UpdateMemberRoleRequest

// DirectUploadOperationsUploadFileMultipartRequestBody defines body for DirectUploadOperationsUploadFile for multipart/form-data ContentType.
type DirectUploadOperationsUploadFileMultipartRequestBody = FileUploadRequest

// GroupTagOperationsCreateTagJSONRequestBody defines body for GroupTagOperationsCreateTag for application/json ContentType.
type GroupTagOperationsCreateTagJSONRequestBody = GroupTagRequest

// GroupTagOperationsUpdateTagJSONRequestBody defines body for GroupTagOperationsUpdateTag for application/json ContentType.
type GroupTagOperationsUpdateTagJSONRequestBody = GroupTagRequest

// MessageOperationsCreateMessageJSONRequestBody defines body for MessageOperationsCreateMessage for application/json ContentType.
type MessageOperationsCreateMessageJSONRequestBody = MessageCreateRequest

// MessageOperationsUpdateMessageJSONRequestBody defines body for MessageOperationsUpdateMessage for application/json ContentType.
type MessageOperationsUpdateMessageJSONRequestBody = MessageUpdateRequest

// LinkPreviewOperationsCreateLinkPreviewsJSONRequestBody defines body for LinkPreviewOperationsCreateLinkPreviews for application/json ContentType.
type LinkPreviewOperationsCreateLinkPreviewsJSONRequestBody = LinkPreviewsRequest

// ReactionOperationsAddReactionJSONRequestBody defines body for ReactionOperationsAddReaction for application/json ContentType.
type ReactionOperationsAddReactionJSONRequestBody = ReactionRequest

// ProfileOperationsUpdateStatusJSONRequestBody defines body for ProfileOperationsUpdateStatus for application/json ContentType.
type ProfileOperationsUpdateStatusJSONRequestBody = StatusUpdateRequest

// TaskOperationsCreateTaskJSONRequestBody defines body for TaskOperationsCreateTask for application/json ContentType.
type TaskOperationsCreateTaskJSONRequestBody = TaskCreateRequest

// TaskOperationsUpdateTaskJSONRequestBody defines body for TaskOperationsUpdateTask for application/json ContentType.
type TaskOperationsUpdateTaskJSONRequestBody = TaskUpdateRequest

// UserOperationsCreateUserJSONRequestBody defines body for UserOperationsCreateUser for application/json ContentType.
type UserOperationsCreateUserJSONRequestBody = UserCreateRequest

// UserOperationsUpdateUserJSONRequestBody defines body for UserOperationsUpdateUser for application/json ContentType.
type UserOperationsUpdateUserJSONRequestBody = UserUpdateRequest

// FormOperationsOpenViewJSONRequestBody defines body for FormOperationsOpenView for application/json ContentType.
type FormOperationsOpenViewJSONRequestBody = OpenViewRequest

// AsViewBlockHeader returns the union data inside the ViewBlockUnion as a ViewBlockHeader
func (t ViewBlockUnion) AsViewBlockHeader() (ViewBlockHeader, error) {
	var body ViewBlockHeader
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockHeader overwrites any union data inside the ViewBlockUnion as the provided ViewBlockHeader
func (t *ViewBlockUnion) FromViewBlockHeader(v ViewBlockHeader) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockHeader performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockHeader
func (t *ViewBlockUnion) MergeViewBlockHeader(v ViewBlockHeader) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockPlainText returns the union data inside the ViewBlockUnion as a ViewBlockPlainText
func (t ViewBlockUnion) AsViewBlockPlainText() (ViewBlockPlainText, error) {
	var body ViewBlockPlainText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockPlainText overwrites any union data inside the ViewBlockUnion as the provided ViewBlockPlainText
func (t *ViewBlockUnion) FromViewBlockPlainText(v ViewBlockPlainText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockPlainText performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockPlainText
func (t *ViewBlockUnion) MergeViewBlockPlainText(v ViewBlockPlainText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockMarkdown returns the union data inside the ViewBlockUnion as a ViewBlockMarkdown
func (t ViewBlockUnion) AsViewBlockMarkdown() (ViewBlockMarkdown, error) {
	var body ViewBlockMarkdown
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockMarkdown overwrites any union data inside the ViewBlockUnion as the provided ViewBlockMarkdown
func (t *ViewBlockUnion) FromViewBlockMarkdown(v ViewBlockMarkdown) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockMarkdown performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockMarkdown
func (t *ViewBlockUnion) MergeViewBlockMarkdown(v ViewBlockMarkdown) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockDivider returns the union data inside the ViewBlockUnion as a ViewBlockDivider
func (t ViewBlockUnion) AsViewBlockDivider() (ViewBlockDivider, error) {
	var body ViewBlockDivider
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockDivider overwrites any union data inside the ViewBlockUnion as the provided ViewBlockDivider
func (t *ViewBlockUnion) FromViewBlockDivider(v ViewBlockDivider) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockDivider performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockDivider
func (t *ViewBlockUnion) MergeViewBlockDivider(v ViewBlockDivider) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockInput returns the union data inside the ViewBlockUnion as a ViewBlockInput
func (t ViewBlockUnion) AsViewBlockInput() (ViewBlockInput, error) {
	var body ViewBlockInput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockInput overwrites any union data inside the ViewBlockUnion as the provided ViewBlockInput
func (t *ViewBlockUnion) FromViewBlockInput(v ViewBlockInput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockInput performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockInput
func (t *ViewBlockUnion) MergeViewBlockInput(v ViewBlockInput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockSelect returns the union data inside the ViewBlockUnion as a ViewBlockSelect
func (t ViewBlockUnion) AsViewBlockSelect() (ViewBlockSelect, error) {
	var body ViewBlockSelect
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockSelect overwrites any union data inside the ViewBlockUnion as the provided ViewBlockSelect
func (t *ViewBlockUnion) FromViewBlockSelect(v ViewBlockSelect) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockSelect performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockSelect
func (t *ViewBlockUnion) MergeViewBlockSelect(v ViewBlockSelect) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockRadio returns the union data inside the ViewBlockUnion as a ViewBlockRadio
func (t ViewBlockUnion) AsViewBlockRadio() (ViewBlockRadio, error) {
	var body ViewBlockRadio
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockRadio overwrites any union data inside the ViewBlockUnion as the provided ViewBlockRadio
func (t *ViewBlockUnion) FromViewBlockRadio(v ViewBlockRadio) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockRadio performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockRadio
func (t *ViewBlockUnion) MergeViewBlockRadio(v ViewBlockRadio) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockCheckbox returns the union data inside the ViewBlockUnion as a ViewBlockCheckbox
func (t ViewBlockUnion) AsViewBlockCheckbox() (ViewBlockCheckbox, error) {
	var body ViewBlockCheckbox
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockCheckbox overwrites any union data inside the ViewBlockUnion as the provided ViewBlockCheckbox
func (t *ViewBlockUnion) FromViewBlockCheckbox(v ViewBlockCheckbox) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockCheckbox performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockCheckbox
func (t *ViewBlockUnion) MergeViewBlockCheckbox(v ViewBlockCheckbox) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockDate returns the union data inside the ViewBlockUnion as a ViewBlockDate
func (t ViewBlockUnion) AsViewBlockDate() (ViewBlockDate, error) {
	var body ViewBlockDate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockDate overwrites any union data inside the ViewBlockUnion as the provided ViewBlockDate
func (t *ViewBlockUnion) FromViewBlockDate(v ViewBlockDate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockDate performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockDate
func (t *ViewBlockUnion) MergeViewBlockDate(v ViewBlockDate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockTime returns the union data inside the ViewBlockUnion as a ViewBlockTime
func (t ViewBlockUnion) AsViewBlockTime() (ViewBlockTime, error) {
	var body ViewBlockTime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockTime overwrites any union data inside the ViewBlockUnion as the provided ViewBlockTime
func (t *ViewBlockUnion) FromViewBlockTime(v ViewBlockTime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockTime performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockTime
func (t *ViewBlockUnion) MergeViewBlockTime(v ViewBlockTime) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsViewBlockFileInput returns the union data inside the ViewBlockUnion as a ViewBlockFileInput
func (t ViewBlockUnion) AsViewBlockFileInput() (ViewBlockFileInput, error) {
	var body ViewBlockFileInput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromViewBlockFileInput overwrites any union data inside the ViewBlockUnion as the provided ViewBlockFileInput
func (t *ViewBlockUnion) FromViewBlockFileInput(v ViewBlockFileInput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeViewBlockFileInput performs a merge with any union data inside the ViewBlockUnion, using the provided ViewBlockFileInput
func (t *ViewBlockUnion) MergeViewBlockFileInput(v ViewBlockFileInput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ViewBlockUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ViewBlockUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageWebhookPayload returns the union data inside the WebhookPayloadUnion as a MessageWebhookPayload
func (t WebhookPayloadUnion) AsMessageWebhookPayload() (MessageWebhookPayload, error) {
	var body MessageWebhookPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageWebhookPayload overwrites any union data inside the WebhookPayloadUnion as the provided MessageWebhookPayload
func (t *WebhookPayloadUnion) FromMessageWebhookPayload(v MessageWebhookPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageWebhookPayload performs a merge with any union data inside the WebhookPayloadUnion, using the provided MessageWebhookPayload
func (t *WebhookPayloadUnion) MergeMessageWebhookPayload(v MessageWebhookPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReactionWebhookPayload returns the union data inside the WebhookPayloadUnion as a ReactionWebhookPayload
func (t WebhookPayloadUnion) AsReactionWebhookPayload() (ReactionWebhookPayload, error) {
	var body ReactionWebhookPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReactionWebhookPayload overwrites any union data inside the WebhookPayloadUnion as the provided ReactionWebhookPayload
func (t *WebhookPayloadUnion) FromReactionWebhookPayload(v ReactionWebhookPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReactionWebhookPayload performs a merge with any union data inside the WebhookPayloadUnion, using the provided ReactionWebhookPayload
func (t *WebhookPayloadUnion) MergeReactionWebhookPayload(v ReactionWebhookPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsButtonWebhookPayload returns the union data inside the WebhookPayloadUnion as a ButtonWebhookPayload
func (t WebhookPayloadUnion) AsButtonWebhookPayload() (ButtonWebhookPayload, error) {
	var body ButtonWebhookPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonWebhookPayload overwrites any union data inside the WebhookPayloadUnion as the provided ButtonWebhookPayload
func (t *WebhookPayloadUnion) FromButtonWebhookPayload(v ButtonWebhookPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonWebhookPayload performs a merge with any union data inside the WebhookPayloadUnion, using the provided ButtonWebhookPayload
func (t *WebhookPayloadUnion) MergeButtonWebhookPayload(v ButtonWebhookPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatMemberWebhookPayload returns the union data inside the WebhookPayloadUnion as a ChatMemberWebhookPayload
func (t WebhookPayloadUnion) AsChatMemberWebhookPayload() (ChatMemberWebhookPayload, error) {
	var body ChatMemberWebhookPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatMemberWebhookPayload overwrites any union data inside the WebhookPayloadUnion as the provided ChatMemberWebhookPayload
func (t *WebhookPayloadUnion) FromChatMemberWebhookPayload(v ChatMemberWebhookPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatMemberWebhookPayload performs a merge with any union data inside the WebhookPayloadUnion, using the provided ChatMemberWebhookPayload
func (t *WebhookPayloadUnion) MergeChatMemberWebhookPayload(v ChatMemberWebhookPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCompanyMemberWebhookPayload returns the union data inside the WebhookPayloadUnion as a CompanyMemberWebhookPayload
func (t WebhookPayloadUnion) AsCompanyMemberWebhookPayload() (CompanyMemberWebhookPayload, error) {
	var body CompanyMemberWebhookPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCompanyMemberWebhookPayload overwrites any union data inside the WebhookPayloadUnion as the provided CompanyMemberWebhookPayload
func (t *WebhookPayloadUnion) FromCompanyMemberWebhookPayload(v CompanyMemberWebhookPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCompanyMemberWebhookPayload performs a merge with any union data inside the WebhookPayloadUnion, using the provided CompanyMemberWebhookPayload
func (t *WebhookPayloadUnion) MergeCompanyMemberWebhookPayload(v CompanyMemberWebhookPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkSharedWebhookPayload returns the union data inside the WebhookPayloadUnion as a LinkSharedWebhookPayload
func (t WebhookPayloadUnion) AsLinkSharedWebhookPayload() (LinkSharedWebhookPayload, error) {
	var body LinkSharedWebhookPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkSharedWebhookPayload overwrites any union data inside the WebhookPayloadUnion as the provided LinkSharedWebhookPayload
func (t *WebhookPayloadUnion) FromLinkSharedWebhookPayload(v LinkSharedWebhookPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkSharedWebhookPayload performs a merge with any union data inside the WebhookPayloadUnion, using the provided LinkSharedWebhookPayload
func (t *WebhookPayloadUnion) MergeLinkSharedWebhookPayload(v LinkSharedWebhookPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WebhookPayloadUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WebhookPayloadUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SecurityOperationsGetAuditEvents request
	SecurityOperationsGetAuditEvents(ctx context.Context, params *SecurityOperationsGetAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BotOperationsUpdateBotWithBody request with any body
	BotOperationsUpdateBotWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BotOperationsUpdateBot(ctx context.Context, id int32, body BotOperationsUpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatOperationsListChats request
	ChatOperationsListChats(ctx context.Context, params *ChatOperationsListChatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatOperationsCreateChatWithBody request with any body
	ChatOperationsCreateChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatOperationsCreateChat(ctx context.Context, body ChatOperationsCreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportOperationsRequestExportWithBody request with any body
	ExportOperationsRequestExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportOperationsRequestExport(ctx context.Context, body ExportOperationsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportOperationsDownloadExport request
	ExportOperationsDownloadExport(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatOperationsGetChat request
	ChatOperationsGetChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatOperationsUpdateChatWithBody request with any body
	ChatOperationsUpdateChatWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatOperationsUpdateChat(ctx context.Context, id int32, body ChatOperationsUpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatOperationsArchiveChat request
	ChatOperationsArchiveChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMemberOperationsAddTagsWithBody request with any body
	ChatMemberOperationsAddTagsWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatMemberOperationsAddTags(ctx context.Context, id int32, body ChatMemberOperationsAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMemberOperationsRemoveTag request
	ChatMemberOperationsRemoveTag(ctx context.Context, id int32, tagId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMemberOperationsLeaveChat request
	ChatMemberOperationsLeaveChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMemberOperationsListMembers request
	ChatMemberOperationsListMembers(ctx context.Context, id int32, params *ChatMemberOperationsListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMemberOperationsAddMembersWithBody request with any body
	ChatMemberOperationsAddMembersWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatMemberOperationsAddMembers(ctx context.Context, id int32, body ChatMemberOperationsAddMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMemberOperationsRemoveMember request
	ChatMemberOperationsRemoveMember(ctx context.Context, id int32, userId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMemberOperationsUpdateMemberRoleWithBody request with any body
	ChatMemberOperationsUpdateMemberRoleWithBody(ctx context.Context, id int32, userId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChatMemberOperationsUpdateMemberRole(ctx context.Context, id int32, userId int32, body ChatMemberOperationsUpdateMemberRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatOperationsUnarchiveChat request
	ChatOperationsUnarchiveChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommonOperationsListProperties request
	CommonOperationsListProperties(ctx context.Context, params *CommonOperationsListPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectUploadOperationsUploadFileWithBody request with any body
	DirectUploadOperationsUploadFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupTagOperationsListTags request
	GroupTagOperationsListTags(ctx context.Context, params *GroupTagOperationsListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupTagOperationsCreateTagWithBody request with any body
	GroupTagOperationsCreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupTagOperationsCreateTag(ctx context.Context, body GroupTagOperationsCreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupTagOperationsDeleteTag request
	GroupTagOperationsDeleteTag(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupTagOperationsGetTag request
	GroupTagOperationsGetTag(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupTagOperationsUpdateTagWithBody request with any body
	GroupTagOperationsUpdateTagWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupTagOperationsUpdateTag(ctx context.Context, id int32, body GroupTagOperationsUpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupTagOperationsGetTagUsers request
	GroupTagOperationsGetTagUsers(ctx context.Context, id int32, params *GroupTagOperationsGetTagUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChatMessageOperationsListChatMessages request
	ChatMessageOperationsListChatMessages(ctx context.Context, params *ChatMessageOperationsListChatMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MessageOperationsCreateMessageWithBody request with any body
	MessageOperationsCreateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MessageOperationsCreateMessage(ctx context.Context, body MessageOperationsCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MessageOperationsDeleteMessage request
	MessageOperationsDeleteMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MessageOperationsGetMessage request
	MessageOperationsGetMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MessageOperationsUpdateMessageWithBody request with any body
	MessageOperationsUpdateMessageWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MessageOperationsUpdateMessage(ctx context.Context, id int32, body MessageOperationsUpdateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPreviewOperationsCreateLinkPreviewsWithBody request with any body
	LinkPreviewOperationsCreateLinkPreviewsWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPreviewOperationsCreateLinkPreviews(ctx context.Context, id int32, body LinkPreviewOperationsCreateLinkPreviewsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MessageOperationsUnpinMessage request
	MessageOperationsUnpinMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MessageOperationsPinMessage request
	MessageOperationsPinMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionOperationsRemoveReaction request
	ReactionOperationsRemoveReaction(ctx context.Context, id int32, params *ReactionOperationsRemoveReactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionOperationsListReactions request
	ReactionOperationsListReactions(ctx context.Context, id int32, params *ReactionOperationsListReactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionOperationsAddReactionWithBody request with any body
	ReactionOperationsAddReactionWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionOperationsAddReaction(ctx context.Context, id int32, body ReactionOperationsAddReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadMemberOperationsListReadMembers request
	ReadMemberOperationsListReadMembers(ctx context.Context, id int32, params *ReadMemberOperationsListReadMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThreadOperationsCreateThread request
	ThreadOperationsCreateThread(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OAuthOperationsGetTokenInfo request
	OAuthOperationsGetTokenInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileOperationsGetProfile request
	ProfileOperationsGetProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileOperationsDeleteStatus request
	ProfileOperationsDeleteStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileOperationsGetStatus request
	ProfileOperationsGetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileOperationsUpdateStatusWithBody request with any body
	ProfileOperationsUpdateStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProfileOperationsUpdateStatus(ctx context.Context, body ProfileOperationsUpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaskOperationsListTasks request
	TaskOperationsListTasks(ctx context.Context, params *TaskOperationsListTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaskOperationsCreateTaskWithBody request with any body
	TaskOperationsCreateTaskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaskOperationsCreateTask(ctx context.Context, body TaskOperationsCreateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaskOperationsDeleteTask request
	TaskOperationsDeleteTask(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaskOperationsGetTask request
	TaskOperationsGetTask(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TaskOperationsUpdateTaskWithBody request with any body
	TaskOperationsUpdateTaskWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TaskOperationsUpdateTask(ctx context.Context, id int32, body TaskOperationsUpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThreadOperationsGetThread request
	ThreadOperationsGetThread(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadOperationsGetUploadParams request
	UploadOperationsGetUploadParams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserOperationsListUsers request
	UserOperationsListUsers(ctx context.Context, params *UserOperationsListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserOperationsCreateUserWithBody request with any body
	UserOperationsCreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserOperationsCreateUser(ctx context.Context, body UserOperationsCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserOperationsDeleteUser request
	UserOperationsDeleteUser(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserOperationsGetUser request
	UserOperationsGetUser(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserOperationsUpdateUserWithBody request with any body
	UserOperationsUpdateUserWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserOperationsUpdateUser(ctx context.Context, id int32, body UserOperationsUpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FormOperationsOpenViewWithBody request with any body
	FormOperationsOpenViewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FormOperationsOpenView(ctx context.Context, body FormOperationsOpenViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BotOperationsGetWebhookEvents request
	BotOperationsGetWebhookEvents(ctx context.Context, params *BotOperationsGetWebhookEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BotOperationsDeleteWebhookEvent request
	BotOperationsDeleteWebhookEvent(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SecurityOperationsGetAuditEvents(ctx context.Context, params *SecurityOperationsGetAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecurityOperationsGetAuditEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BotOperationsUpdateBotWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBotOperationsUpdateBotRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BotOperationsUpdateBot(ctx context.Context, id int32, body BotOperationsUpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBotOperationsUpdateBotRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsListChats(ctx context.Context, params *ChatOperationsListChatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsListChatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsCreateChatWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsCreateChatRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsCreateChat(ctx context.Context, body ChatOperationsCreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsCreateChatRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportOperationsRequestExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportOperationsRequestExportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportOperationsRequestExport(ctx context.Context, body ExportOperationsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportOperationsRequestExportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportOperationsDownloadExport(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportOperationsDownloadExportRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsGetChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsGetChatRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsUpdateChatWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsUpdateChatRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsUpdateChat(ctx context.Context, id int32, body ChatOperationsUpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsUpdateChatRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsArchiveChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsArchiveChatRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsAddTagsWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsAddTagsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsAddTags(ctx context.Context, id int32, body ChatMemberOperationsAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsAddTagsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsRemoveTag(ctx context.Context, id int32, tagId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsRemoveTagRequest(c.Server, id, tagId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsLeaveChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsLeaveChatRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsListMembers(ctx context.Context, id int32, params *ChatMemberOperationsListMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsListMembersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsAddMembersWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsAddMembersRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsAddMembers(ctx context.Context, id int32, body ChatMemberOperationsAddMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsAddMembersRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsRemoveMember(ctx context.Context, id int32, userId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsRemoveMemberRequest(c.Server, id, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsUpdateMemberRoleWithBody(ctx context.Context, id int32, userId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsUpdateMemberRoleRequestWithBody(c.Server, id, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMemberOperationsUpdateMemberRole(ctx context.Context, id int32, userId int32, body ChatMemberOperationsUpdateMemberRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMemberOperationsUpdateMemberRoleRequest(c.Server, id, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatOperationsUnarchiveChat(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatOperationsUnarchiveChatRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommonOperationsListProperties(ctx context.Context, params *CommonOperationsListPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommonOperationsListPropertiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectUploadOperationsUploadFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectUploadOperationsUploadFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsListTags(ctx context.Context, params *GroupTagOperationsListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsListTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsCreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsCreateTagRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsCreateTag(ctx context.Context, body GroupTagOperationsCreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsCreateTagRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsDeleteTag(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsDeleteTagRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsGetTag(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsGetTagRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsUpdateTagWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsUpdateTagRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsUpdateTag(ctx context.Context, id int32, body GroupTagOperationsUpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsUpdateTagRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupTagOperationsGetTagUsers(ctx context.Context, id int32, params *GroupTagOperationsGetTagUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupTagOperationsGetTagUsersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChatMessageOperationsListChatMessages(ctx context.Context, params *ChatMessageOperationsListChatMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChatMessageOperationsListChatMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsCreateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsCreateMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsCreateMessage(ctx context.Context, body MessageOperationsCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsCreateMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsDeleteMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsDeleteMessageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsGetMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsGetMessageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsUpdateMessageWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsUpdateMessageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsUpdateMessage(ctx context.Context, id int32, body MessageOperationsUpdateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsUpdateMessageRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPreviewOperationsCreateLinkPreviewsWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPreviewOperationsCreateLinkPreviewsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPreviewOperationsCreateLinkPreviews(ctx context.Context, id int32, body LinkPreviewOperationsCreateLinkPreviewsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPreviewOperationsCreateLinkPreviewsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsUnpinMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsUnpinMessageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MessageOperationsPinMessage(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMessageOperationsPinMessageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionOperationsRemoveReaction(ctx context.Context, id int32, params *ReactionOperationsRemoveReactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionOperationsRemoveReactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionOperationsListReactions(ctx context.Context, id int32, params *ReactionOperationsListReactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionOperationsListReactionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionOperationsAddReactionWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionOperationsAddReactionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionOperationsAddReaction(ctx context.Context, id int32, body ReactionOperationsAddReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionOperationsAddReactionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadMemberOperationsListReadMembers(ctx context.Context, id int32, params *ReadMemberOperationsListReadMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadMemberOperationsListReadMembersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadOperationsCreateThread(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadOperationsCreateThreadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OAuthOperationsGetTokenInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOAuthOperationsGetTokenInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileOperationsGetProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileOperationsGetProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileOperationsDeleteStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileOperationsDeleteStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileOperationsGetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileOperationsGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileOperationsUpdateStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileOperationsUpdateStatusRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileOperationsUpdateStatus(ctx context.Context, body ProfileOperationsUpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileOperationsUpdateStatusRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaskOperationsListTasks(ctx context.Context, params *TaskOperationsListTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaskOperationsListTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaskOperationsCreateTaskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaskOperationsCreateTaskRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaskOperationsCreateTask(ctx context.Context, body TaskOperationsCreateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaskOperationsCreateTaskRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaskOperationsDeleteTask(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaskOperationsDeleteTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaskOperationsGetTask(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaskOperationsGetTaskRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaskOperationsUpdateTaskWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaskOperationsUpdateTaskRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TaskOperationsUpdateTask(ctx context.Context, id int32, body TaskOperationsUpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTaskOperationsUpdateTaskRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadOperationsGetThread(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadOperationsGetThreadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadOperationsGetUploadParams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadOperationsGetUploadParamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOperationsListUsers(ctx context.Context, params *UserOperationsListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOperationsListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOperationsCreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOperationsCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOperationsCreateUser(ctx context.Context, body UserOperationsCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOperationsCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOperationsDeleteUser(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOperationsDeleteUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOperationsGetUser(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOperationsGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOperationsUpdateUserWithBody(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOperationsUpdateUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOperationsUpdateUser(ctx context.Context, id int32, body UserOperationsUpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOperationsUpdateUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FormOperationsOpenViewWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFormOperationsOpenViewRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FormOperationsOpenView(ctx context.Context, body FormOperationsOpenViewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFormOperationsOpenViewRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BotOperationsGetWebhookEvents(ctx context.Context, params *BotOperationsGetWebhookEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBotOperationsGetWebhookEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BotOperationsDeleteWebhookEvent(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBotOperationsDeleteWebhookEventRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSecurityOperationsGetAuditEventsRequest generates requests for SecurityOperationsGetAuditEvents
func NewSecurityOperationsGetAuditEventsRequest(server string, params *SecurityOperationsGetAuditEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit_events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "start_time", runtime.ParamLocationQuery, params.StartTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "end_time", runtime.ParamLocationQuery, params.EndTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.EventKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "event_key", runtime.ParamLocationQuery, *params.EventKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "actor_id", runtime.ParamLocationQuery, *params.ActorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "actor_type", runtime.ParamLocationQuery, *params.ActorType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "entity_id", runtime.ParamLocationQuery, *params.EntityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "entity_type", runtime.ParamLocationQuery, *params.EntityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBotOperationsUpdateBotRequest calls the generic BotOperationsUpdateBot builder with application/json body
func NewBotOperationsUpdateBotRequest(server string, id int32, body BotOperationsUpdateBotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBotOperationsUpdateBotRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBotOperationsUpdateBotRequestWithBody generates requests for BotOperationsUpdateBot with any type of body
func NewBotOperationsUpdateBotRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatOperationsListChatsRequest generates requests for ChatOperationsListChats
func NewChatOperationsListChatsRequest(server string, params *ChatOperationsListChatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort[{field}]", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Availability != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "availability", runtime.ParamLocationQuery, *params.Availability); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastMessageAtAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "last_message_at_after", runtime.ParamLocationQuery, *params.LastMessageAtAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastMessageAtBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "last_message_at_before", runtime.ParamLocationQuery, *params.LastMessageAtBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Personal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "personal", runtime.ParamLocationQuery, *params.Personal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatOperationsCreateChatRequest calls the generic ChatOperationsCreateChat builder with application/json body
func NewChatOperationsCreateChatRequest(server string, body ChatOperationsCreateChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatOperationsCreateChatRequestWithBody(server, "application/json", bodyReader)
}

// NewChatOperationsCreateChatRequestWithBody generates requests for ChatOperationsCreateChat with any type of body
func NewChatOperationsCreateChatRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportOperationsRequestExportRequest calls the generic ExportOperationsRequestExport builder with application/json body
func NewExportOperationsRequestExportRequest(server string, body ExportOperationsRequestExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportOperationsRequestExportRequestWithBody(server, "application/json", bodyReader)
}

// NewExportOperationsRequestExportRequestWithBody generates requests for ExportOperationsRequestExport with any type of body
func NewExportOperationsRequestExportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportOperationsDownloadExportRequest generates requests for ExportOperationsDownloadExport
func NewExportOperationsDownloadExportRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/exports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatOperationsGetChatRequest generates requests for ChatOperationsGetChat
func NewChatOperationsGetChatRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatOperationsUpdateChatRequest calls the generic ChatOperationsUpdateChat builder with application/json body
func NewChatOperationsUpdateChatRequest(server string, id int32, body ChatOperationsUpdateChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatOperationsUpdateChatRequestWithBody(server, id, "application/json", bodyReader)
}

// NewChatOperationsUpdateChatRequestWithBody generates requests for ChatOperationsUpdateChat with any type of body
func NewChatOperationsUpdateChatRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatOperationsArchiveChatRequest generates requests for ChatOperationsArchiveChat
func NewChatOperationsArchiveChatRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatMemberOperationsAddTagsRequest calls the generic ChatMemberOperationsAddTags builder with application/json body
func NewChatMemberOperationsAddTagsRequest(server string, id int32, body ChatMemberOperationsAddTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatMemberOperationsAddTagsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewChatMemberOperationsAddTagsRequestWithBody generates requests for ChatMemberOperationsAddTags with any type of body
func NewChatMemberOperationsAddTagsRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/group_tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatMemberOperationsRemoveTagRequest generates requests for ChatMemberOperationsRemoveTag
func NewChatMemberOperationsRemoveTagRequest(server string, id int32, tagId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag_id", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/group_tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatMemberOperationsLeaveChatRequest generates requests for ChatMemberOperationsLeaveChat
func NewChatMemberOperationsLeaveChatRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/leave", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatMemberOperationsListMembersRequest generates requests for ChatMemberOperationsListMembers
func NewChatMemberOperationsListMembersRequest(server string, id int32, params *ChatMemberOperationsListMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Role != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatMemberOperationsAddMembersRequest calls the generic ChatMemberOperationsAddMembers builder with application/json body
func NewChatMemberOperationsAddMembersRequest(server string, id int32, body ChatMemberOperationsAddMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatMemberOperationsAddMembersRequestWithBody(server, id, "application/json", bodyReader)
}

// NewChatMemberOperationsAddMembersRequestWithBody generates requests for ChatMemberOperationsAddMembers with any type of body
func NewChatMemberOperationsAddMembersRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatMemberOperationsRemoveMemberRequest generates requests for ChatMemberOperationsRemoveMember
func NewChatMemberOperationsRemoveMemberRequest(server string, id int32, userId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatMemberOperationsUpdateMemberRoleRequest calls the generic ChatMemberOperationsUpdateMemberRole builder with application/json body
func NewChatMemberOperationsUpdateMemberRoleRequest(server string, id int32, userId int32, body ChatMemberOperationsUpdateMemberRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChatMemberOperationsUpdateMemberRoleRequestWithBody(server, id, userId, "application/json", bodyReader)
}

// NewChatMemberOperationsUpdateMemberRoleRequestWithBody generates requests for ChatMemberOperationsUpdateMemberRole with any type of body
func NewChatMemberOperationsUpdateMemberRoleRequestWithBody(server string, id int32, userId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChatOperationsUnarchiveChatRequest generates requests for ChatOperationsUnarchiveChat
func NewChatOperationsUnarchiveChatRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chats/%s/unarchive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommonOperationsListPropertiesRequest generates requests for CommonOperationsListProperties
func NewCommonOperationsListPropertiesRequest(server string, params *CommonOperationsListPropertiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom_properties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "entity_type", runtime.ParamLocationQuery, params.EntityType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDirectUploadOperationsUploadFileRequestWithBody generates requests for DirectUploadOperationsUploadFile with any type of body
func NewDirectUploadOperationsUploadFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/direct_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupTagOperationsListTagsRequest generates requests for GroupTagOperationsListTags
func NewGroupTagOperationsListTagsRequest(server string, params *GroupTagOperationsListTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group_tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupTagOperationsCreateTagRequest calls the generic GroupTagOperationsCreateTag builder with application/json body
func NewGroupTagOperationsCreateTagRequest(server string, body GroupTagOperationsCreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupTagOperationsCreateTagRequestWithBody(server, "application/json", bodyReader)
}

// NewGroupTagOperationsCreateTagRequestWithBody generates requests for GroupTagOperationsCreateTag with any type of body
func NewGroupTagOperationsCreateTagRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group_tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupTagOperationsDeleteTagRequest generates requests for GroupTagOperationsDeleteTag
func NewGroupTagOperationsDeleteTagRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group_tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupTagOperationsGetTagRequest generates requests for GroupTagOperationsGetTag
func NewGroupTagOperationsGetTagRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group_tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGroupTagOperationsUpdateTagRequest calls the generic GroupTagOperationsUpdateTag builder with application/json body
func NewGroupTagOperationsUpdateTagRequest(server string, id int32, body GroupTagOperationsUpdateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupTagOperationsUpdateTagRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGroupTagOperationsUpdateTagRequestWithBody generates requests for GroupTagOperationsUpdateTag with any type of body
func NewGroupTagOperationsUpdateTagRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group_tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGroupTagOperationsGetTagUsersRequest generates requests for GroupTagOperationsGetTagUsers
func NewGroupTagOperationsGetTagUsersRequest(server string, id int32, params *GroupTagOperationsGetTagUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group_tags/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChatMessageOperationsListChatMessagesRequest generates requests for ChatMessageOperationsListChatMessages
func NewChatMessageOperationsListChatMessagesRequest(server string, params *ChatMessageOperationsListChatMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "chat_id", runtime.ParamLocationQuery, params.ChatId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort[{field}]", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMessageOperationsCreateMessageRequest calls the generic MessageOperationsCreateMessage builder with application/json body
func NewMessageOperationsCreateMessageRequest(server string, body MessageOperationsCreateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMessageOperationsCreateMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewMessageOperationsCreateMessageRequestWithBody generates requests for MessageOperationsCreateMessage with any type of body
func NewMessageOperationsCreateMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMessageOperationsDeleteMessageRequest generates requests for MessageOperationsDeleteMessage
func NewMessageOperationsDeleteMessageRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMessageOperationsGetMessageRequest generates requests for MessageOperationsGetMessage
func NewMessageOperationsGetMessageRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMessageOperationsUpdateMessageRequest calls the generic MessageOperationsUpdateMessage builder with application/json body
func NewMessageOperationsUpdateMessageRequest(server string, id int32, body MessageOperationsUpdateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMessageOperationsUpdateMessageRequestWithBody(server, id, "application/json", bodyReader)
}

// NewMessageOperationsUpdateMessageRequestWithBody generates requests for MessageOperationsUpdateMessage with any type of body
func NewMessageOperationsUpdateMessageRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLinkPreviewOperationsCreateLinkPreviewsRequest calls the generic LinkPreviewOperationsCreateLinkPreviews builder with application/json body
func NewLinkPreviewOperationsCreateLinkPreviewsRequest(server string, id int32, body LinkPreviewOperationsCreateLinkPreviewsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPreviewOperationsCreateLinkPreviewsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLinkPreviewOperationsCreateLinkPreviewsRequestWithBody generates requests for LinkPreviewOperationsCreateLinkPreviews with any type of body
func NewLinkPreviewOperationsCreateLinkPreviewsRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/link_previews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMessageOperationsUnpinMessageRequest generates requests for MessageOperationsUnpinMessage
func NewMessageOperationsUnpinMessageRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/pin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMessageOperationsPinMessageRequest generates requests for MessageOperationsPinMessage
func NewMessageOperationsPinMessageRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/pin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionOperationsRemoveReactionRequest generates requests for ReactionOperationsRemoveReaction
func NewReactionOperationsRemoveReactionRequest(server string, id int32, params *ReactionOperationsRemoveReactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/reactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionOperationsListReactionsRequest generates requests for ReactionOperationsListReactions
func NewReactionOperationsListReactionsRequest(server string, id int32, params *ReactionOperationsListReactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/reactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionOperationsAddReactionRequest calls the generic ReactionOperationsAddReaction builder with application/json body
func NewReactionOperationsAddReactionRequest(server string, id int32, body ReactionOperationsAddReactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionOperationsAddReactionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReactionOperationsAddReactionRequestWithBody generates requests for ReactionOperationsAddReaction with any type of body
func NewReactionOperationsAddReactionRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/reactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadMemberOperationsListReadMembersRequest generates requests for ReadMemberOperationsListReadMembers
func NewReadMemberOperationsListReadMembersRequest(server string, id int32, params *ReadMemberOperationsListReadMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/read_member_ids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewThreadOperationsCreateThreadRequest generates requests for ThreadOperationsCreateThread
func NewThreadOperationsCreateThreadRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages/%s/thread", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOAuthOperationsGetTokenInfoRequest generates requests for OAuthOperationsGetTokenInfo
func NewOAuthOperationsGetTokenInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/token/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfileOperationsGetProfileRequest generates requests for ProfileOperationsGetProfile
func NewProfileOperationsGetProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfileOperationsDeleteStatusRequest generates requests for ProfileOperationsDeleteStatus
func NewProfileOperationsDeleteStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfileOperationsGetStatusRequest generates requests for ProfileOperationsGetStatus
func NewProfileOperationsGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfileOperationsUpdateStatusRequest calls the generic ProfileOperationsUpdateStatus builder with application/json body
func NewProfileOperationsUpdateStatusRequest(server string, body ProfileOperationsUpdateStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProfileOperationsUpdateStatusRequestWithBody(server, "application/json", bodyReader)
}

// NewProfileOperationsUpdateStatusRequestWithBody generates requests for ProfileOperationsUpdateStatus with any type of body
func NewProfileOperationsUpdateStatusRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaskOperationsListTasksRequest generates requests for TaskOperationsListTasks
func NewTaskOperationsListTasksRequest(server string, params *TaskOperationsListTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaskOperationsCreateTaskRequest calls the generic TaskOperationsCreateTask builder with application/json body
func NewTaskOperationsCreateTaskRequest(server string, body TaskOperationsCreateTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaskOperationsCreateTaskRequestWithBody(server, "application/json", bodyReader)
}

// NewTaskOperationsCreateTaskRequestWithBody generates requests for TaskOperationsCreateTask with any type of body
func NewTaskOperationsCreateTaskRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTaskOperationsDeleteTaskRequest generates requests for TaskOperationsDeleteTask
func NewTaskOperationsDeleteTaskRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaskOperationsGetTaskRequest generates requests for TaskOperationsGetTask
func NewTaskOperationsGetTaskRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTaskOperationsUpdateTaskRequest calls the generic TaskOperationsUpdateTask builder with application/json body
func NewTaskOperationsUpdateTaskRequest(server string, id int32, body TaskOperationsUpdateTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTaskOperationsUpdateTaskRequestWithBody(server, id, "application/json", bodyReader)
}

// NewTaskOperationsUpdateTaskRequestWithBody generates requests for TaskOperationsUpdateTask with any type of body
func NewTaskOperationsUpdateTaskRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewThreadOperationsGetThreadRequest generates requests for ThreadOperationsGetThread
func NewThreadOperationsGetThreadRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadOperationsGetUploadParamsRequest generates requests for UploadOperationsGetUploadParams
func NewUploadOperationsGetUploadParamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserOperationsListUsersRequest generates requests for UserOperationsListUsers
func NewUserOperationsListUsersRequest(server string, params *UserOperationsListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserOperationsCreateUserRequest calls the generic UserOperationsCreateUser builder with application/json body
func NewUserOperationsCreateUserRequest(server string, body UserOperationsCreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserOperationsCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUserOperationsCreateUserRequestWithBody generates requests for UserOperationsCreateUser with any type of body
func NewUserOperationsCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserOperationsDeleteUserRequest generates requests for UserOperationsDeleteUser
func NewUserOperationsDeleteUserRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserOperationsGetUserRequest generates requests for UserOperationsGetUser
func NewUserOperationsGetUserRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserOperationsUpdateUserRequest calls the generic UserOperationsUpdateUser builder with application/json body
func NewUserOperationsUpdateUserRequest(server string, id int32, body UserOperationsUpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserOperationsUpdateUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUserOperationsUpdateUserRequestWithBody generates requests for UserOperationsUpdateUser with any type of body
func NewUserOperationsUpdateUserRequestWithBody(server string, id int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFormOperationsOpenViewRequest calls the generic FormOperationsOpenView builder with application/json body
func NewFormOperationsOpenViewRequest(server string, body FormOperationsOpenViewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFormOperationsOpenViewRequestWithBody(server, "application/json", bodyReader)
}

// NewFormOperationsOpenViewRequestWithBody generates requests for FormOperationsOpenView with any type of body
func NewFormOperationsOpenViewRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/views/open")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBotOperationsGetWebhookEventsRequest generates requests for BotOperationsGetWebhookEvents
func NewBotOperationsGetWebhookEventsRequest(server string, params *BotOperationsGetWebhookEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBotOperationsDeleteWebhookEventRequest generates requests for BotOperationsDeleteWebhookEvent
func NewBotOperationsDeleteWebhookEventRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SecurityOperationsGetAuditEventsWithResponse request
	SecurityOperationsGetAuditEventsWithResponse(ctx context.Context, params *SecurityOperationsGetAuditEventsParams, reqEditors ...RequestEditorFn) (*SecurityOperationsGetAuditEventsResponse, error)

	// BotOperationsUpdateBotWithBodyWithResponse request with any body
	BotOperationsUpdateBotWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BotOperationsUpdateBotResponse, error)

	BotOperationsUpdateBotWithResponse(ctx context.Context, id int32, body BotOperationsUpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*BotOperationsUpdateBotResponse, error)

	// ChatOperationsListChatsWithResponse request
	ChatOperationsListChatsWithResponse(ctx context.Context, params *ChatOperationsListChatsParams, reqEditors ...RequestEditorFn) (*ChatOperationsListChatsResponse, error)

	// ChatOperationsCreateChatWithBodyWithResponse request with any body
	ChatOperationsCreateChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatOperationsCreateChatResponse, error)

	ChatOperationsCreateChatWithResponse(ctx context.Context, body ChatOperationsCreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatOperationsCreateChatResponse, error)

	// ExportOperationsRequestExportWithBodyWithResponse request with any body
	ExportOperationsRequestExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportOperationsRequestExportResponse, error)

	ExportOperationsRequestExportWithResponse(ctx context.Context, body ExportOperationsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportOperationsRequestExportResponse, error)

	// ExportOperationsDownloadExportWithResponse request
	ExportOperationsDownloadExportWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ExportOperationsDownloadExportResponse, error)

	// ChatOperationsGetChatWithResponse request
	ChatOperationsGetChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatOperationsGetChatResponse, error)

	// ChatOperationsUpdateChatWithBodyWithResponse request with any body
	ChatOperationsUpdateChatWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatOperationsUpdateChatResponse, error)

	ChatOperationsUpdateChatWithResponse(ctx context.Context, id int32, body ChatOperationsUpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatOperationsUpdateChatResponse, error)

	// ChatOperationsArchiveChatWithResponse request
	ChatOperationsArchiveChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatOperationsArchiveChatResponse, error)

	// ChatMemberOperationsAddTagsWithBodyWithResponse request with any body
	ChatMemberOperationsAddTagsWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddTagsResponse, error)

	ChatMemberOperationsAddTagsWithResponse(ctx context.Context, id int32, body ChatMemberOperationsAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddTagsResponse, error)

	// ChatMemberOperationsRemoveTagWithResponse request
	ChatMemberOperationsRemoveTagWithResponse(ctx context.Context, id int32, tagId int32, reqEditors ...RequestEditorFn) (*ChatMemberOperationsRemoveTagResponse, error)

	// ChatMemberOperationsLeaveChatWithResponse request
	ChatMemberOperationsLeaveChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatMemberOperationsLeaveChatResponse, error)

	// ChatMemberOperationsListMembersWithResponse request
	ChatMemberOperationsListMembersWithResponse(ctx context.Context, id int32, params *ChatMemberOperationsListMembersParams, reqEditors ...RequestEditorFn) (*ChatMemberOperationsListMembersResponse, error)

	// ChatMemberOperationsAddMembersWithBodyWithResponse request with any body
	ChatMemberOperationsAddMembersWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddMembersResponse, error)

	ChatMemberOperationsAddMembersWithResponse(ctx context.Context, id int32, body ChatMemberOperationsAddMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddMembersResponse, error)

	// ChatMemberOperationsRemoveMemberWithResponse request
	ChatMemberOperationsRemoveMemberWithResponse(ctx context.Context, id int32, userId int32, reqEditors ...RequestEditorFn) (*ChatMemberOperationsRemoveMemberResponse, error)

	// ChatMemberOperationsUpdateMemberRoleWithBodyWithResponse request with any body
	ChatMemberOperationsUpdateMemberRoleWithBodyWithResponse(ctx context.Context, id int32, userId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatMemberOperationsUpdateMemberRoleResponse, error)

	ChatMemberOperationsUpdateMemberRoleWithResponse(ctx context.Context, id int32, userId int32, body ChatMemberOperationsUpdateMemberRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatMemberOperationsUpdateMemberRoleResponse, error)

	// ChatOperationsUnarchiveChatWithResponse request
	ChatOperationsUnarchiveChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatOperationsUnarchiveChatResponse, error)

	// CommonOperationsListPropertiesWithResponse request
	CommonOperationsListPropertiesWithResponse(ctx context.Context, params *CommonOperationsListPropertiesParams, reqEditors ...RequestEditorFn) (*CommonOperationsListPropertiesResponse, error)

	// DirectUploadOperationsUploadFileWithBodyWithResponse request with any body
	DirectUploadOperationsUploadFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectUploadOperationsUploadFileResponse, error)

	// GroupTagOperationsListTagsWithResponse request
	GroupTagOperationsListTagsWithResponse(ctx context.Context, params *GroupTagOperationsListTagsParams, reqEditors ...RequestEditorFn) (*GroupTagOperationsListTagsResponse, error)

	// GroupTagOperationsCreateTagWithBodyWithResponse request with any body
	GroupTagOperationsCreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupTagOperationsCreateTagResponse, error)

	GroupTagOperationsCreateTagWithResponse(ctx context.Context, body GroupTagOperationsCreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupTagOperationsCreateTagResponse, error)

	// GroupTagOperationsDeleteTagWithResponse request
	GroupTagOperationsDeleteTagWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*GroupTagOperationsDeleteTagResponse, error)

	// GroupTagOperationsGetTagWithResponse request
	GroupTagOperationsGetTagWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*GroupTagOperationsGetTagResponse, error)

	// GroupTagOperationsUpdateTagWithBodyWithResponse request with any body
	GroupTagOperationsUpdateTagWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupTagOperationsUpdateTagResponse, error)

	GroupTagOperationsUpdateTagWithResponse(ctx context.Context, id int32, body GroupTagOperationsUpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupTagOperationsUpdateTagResponse, error)

	// GroupTagOperationsGetTagUsersWithResponse request
	GroupTagOperationsGetTagUsersWithResponse(ctx context.Context, id int32, params *GroupTagOperationsGetTagUsersParams, reqEditors ...RequestEditorFn) (*GroupTagOperationsGetTagUsersResponse, error)

	// ChatMessageOperationsListChatMessagesWithResponse request
	ChatMessageOperationsListChatMessagesWithResponse(ctx context.Context, params *ChatMessageOperationsListChatMessagesParams, reqEditors ...RequestEditorFn) (*ChatMessageOperationsListChatMessagesResponse, error)

	// MessageOperationsCreateMessageWithBodyWithResponse request with any body
	MessageOperationsCreateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MessageOperationsCreateMessageResponse, error)

	MessageOperationsCreateMessageWithResponse(ctx context.Context, body MessageOperationsCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*MessageOperationsCreateMessageResponse, error)

	// MessageOperationsDeleteMessageWithResponse request
	MessageOperationsDeleteMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsDeleteMessageResponse, error)

	// MessageOperationsGetMessageWithResponse request
	MessageOperationsGetMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsGetMessageResponse, error)

	// MessageOperationsUpdateMessageWithBodyWithResponse request with any body
	MessageOperationsUpdateMessageWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MessageOperationsUpdateMessageResponse, error)

	MessageOperationsUpdateMessageWithResponse(ctx context.Context, id int32, body MessageOperationsUpdateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*MessageOperationsUpdateMessageResponse, error)

	// LinkPreviewOperationsCreateLinkPreviewsWithBodyWithResponse request with any body
	LinkPreviewOperationsCreateLinkPreviewsWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPreviewOperationsCreateLinkPreviewsResponse, error)

	LinkPreviewOperationsCreateLinkPreviewsWithResponse(ctx context.Context, id int32, body LinkPreviewOperationsCreateLinkPreviewsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPreviewOperationsCreateLinkPreviewsResponse, error)

	// MessageOperationsUnpinMessageWithResponse request
	MessageOperationsUnpinMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsUnpinMessageResponse, error)

	// MessageOperationsPinMessageWithResponse request
	MessageOperationsPinMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsPinMessageResponse, error)

	// ReactionOperationsRemoveReactionWithResponse request
	ReactionOperationsRemoveReactionWithResponse(ctx context.Context, id int32, params *ReactionOperationsRemoveReactionParams, reqEditors ...RequestEditorFn) (*ReactionOperationsRemoveReactionResponse, error)

	// ReactionOperationsListReactionsWithResponse request
	ReactionOperationsListReactionsWithResponse(ctx context.Context, id int32, params *ReactionOperationsListReactionsParams, reqEditors ...RequestEditorFn) (*ReactionOperationsListReactionsResponse, error)

	// ReactionOperationsAddReactionWithBodyWithResponse request with any body
	ReactionOperationsAddReactionWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionOperationsAddReactionResponse, error)

	ReactionOperationsAddReactionWithResponse(ctx context.Context, id int32, body ReactionOperationsAddReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionOperationsAddReactionResponse, error)

	// ReadMemberOperationsListReadMembersWithResponse request
	ReadMemberOperationsListReadMembersWithResponse(ctx context.Context, id int32, params *ReadMemberOperationsListReadMembersParams, reqEditors ...RequestEditorFn) (*ReadMemberOperationsListReadMembersResponse, error)

	// ThreadOperationsCreateThreadWithResponse request
	ThreadOperationsCreateThreadWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ThreadOperationsCreateThreadResponse, error)

	// OAuthOperationsGetTokenInfoWithResponse request
	OAuthOperationsGetTokenInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OAuthOperationsGetTokenInfoResponse, error)

	// ProfileOperationsGetProfileWithResponse request
	ProfileOperationsGetProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileOperationsGetProfileResponse, error)

	// ProfileOperationsDeleteStatusWithResponse request
	ProfileOperationsDeleteStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileOperationsDeleteStatusResponse, error)

	// ProfileOperationsGetStatusWithResponse request
	ProfileOperationsGetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileOperationsGetStatusResponse, error)

	// ProfileOperationsUpdateStatusWithBodyWithResponse request with any body
	ProfileOperationsUpdateStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProfileOperationsUpdateStatusResponse, error)

	ProfileOperationsUpdateStatusWithResponse(ctx context.Context, body ProfileOperationsUpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ProfileOperationsUpdateStatusResponse, error)

	// TaskOperationsListTasksWithResponse request
	TaskOperationsListTasksWithResponse(ctx context.Context, params *TaskOperationsListTasksParams, reqEditors ...RequestEditorFn) (*TaskOperationsListTasksResponse, error)

	// TaskOperationsCreateTaskWithBodyWithResponse request with any body
	TaskOperationsCreateTaskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaskOperationsCreateTaskResponse, error)

	TaskOperationsCreateTaskWithResponse(ctx context.Context, body TaskOperationsCreateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*TaskOperationsCreateTaskResponse, error)

	// TaskOperationsDeleteTaskWithResponse request
	TaskOperationsDeleteTaskWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*TaskOperationsDeleteTaskResponse, error)

	// TaskOperationsGetTaskWithResponse request
	TaskOperationsGetTaskWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*TaskOperationsGetTaskResponse, error)

	// TaskOperationsUpdateTaskWithBodyWithResponse request with any body
	TaskOperationsUpdateTaskWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaskOperationsUpdateTaskResponse, error)

	TaskOperationsUpdateTaskWithResponse(ctx context.Context, id int32, body TaskOperationsUpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*TaskOperationsUpdateTaskResponse, error)

	// ThreadOperationsGetThreadWithResponse request
	ThreadOperationsGetThreadWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ThreadOperationsGetThreadResponse, error)

	// UploadOperationsGetUploadParamsWithResponse request
	UploadOperationsGetUploadParamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UploadOperationsGetUploadParamsResponse, error)

	// UserOperationsListUsersWithResponse request
	UserOperationsListUsersWithResponse(ctx context.Context, params *UserOperationsListUsersParams, reqEditors ...RequestEditorFn) (*UserOperationsListUsersResponse, error)

	// UserOperationsCreateUserWithBodyWithResponse request with any body
	UserOperationsCreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserOperationsCreateUserResponse, error)

	UserOperationsCreateUserWithResponse(ctx context.Context, body UserOperationsCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserOperationsCreateUserResponse, error)

	// UserOperationsDeleteUserWithResponse request
	UserOperationsDeleteUserWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*UserOperationsDeleteUserResponse, error)

	// UserOperationsGetUserWithResponse request
	UserOperationsGetUserWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*UserOperationsGetUserResponse, error)

	// UserOperationsUpdateUserWithBodyWithResponse request with any body
	UserOperationsUpdateUserWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserOperationsUpdateUserResponse, error)

	UserOperationsUpdateUserWithResponse(ctx context.Context, id int32, body UserOperationsUpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserOperationsUpdateUserResponse, error)

	// FormOperationsOpenViewWithBodyWithResponse request with any body
	FormOperationsOpenViewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FormOperationsOpenViewResponse, error)

	FormOperationsOpenViewWithResponse(ctx context.Context, body FormOperationsOpenViewJSONRequestBody, reqEditors ...RequestEditorFn) (*FormOperationsOpenViewResponse, error)

	// BotOperationsGetWebhookEventsWithResponse request
	BotOperationsGetWebhookEventsWithResponse(ctx context.Context, params *BotOperationsGetWebhookEventsParams, reqEditors ...RequestEditorFn) (*BotOperationsGetWebhookEventsResponse, error)

	// BotOperationsDeleteWebhookEventWithResponse request
	BotOperationsDeleteWebhookEventWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*BotOperationsDeleteWebhookEventResponse, error)
}

type SecurityOperationsGetAuditEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []AuditEvent `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r SecurityOperationsGetAuditEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecurityOperationsGetAuditEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BotOperationsUpdateBotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Ответ с данными бота
		Data BotResponse `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r BotOperationsUpdateBotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BotOperationsUpdateBotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatOperationsListChatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Chat `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatOperationsListChatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatOperationsListChatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatOperationsCreateChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Чат
		Data Chat `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatOperationsCreateChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatOperationsCreateChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportOperationsRequestExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *struct {
		union json.RawMessage
	}
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ExportOperationsRequestExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportOperationsRequestExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportOperationsDownloadExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *OAuthError
	JSON403      *struct {
		union json.RawMessage
	}
	JSON404 *ApiError
}
type ExportOperationsDownloadExport4031 struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r ExportOperationsDownloadExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportOperationsDownloadExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatOperationsGetChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Чат
		Data Chat `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatOperationsGetChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatOperationsGetChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatOperationsUpdateChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Чат
		Data Chat `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatOperationsUpdateChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatOperationsUpdateChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatOperationsArchiveChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatOperationsArchiveChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatOperationsArchiveChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMemberOperationsAddTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMemberOperationsAddTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMemberOperationsAddTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMemberOperationsRemoveTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMemberOperationsRemoveTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMemberOperationsRemoveTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMemberOperationsLeaveChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMemberOperationsLeaveChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMemberOperationsLeaveChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMemberOperationsListMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []User `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMemberOperationsListMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMemberOperationsListMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMemberOperationsAddMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMemberOperationsAddMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMemberOperationsAddMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMemberOperationsRemoveMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMemberOperationsRemoveMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMemberOperationsRemoveMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMemberOperationsUpdateMemberRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMemberOperationsUpdateMemberRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMemberOperationsUpdateMemberRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatOperationsUnarchiveChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatOperationsUnarchiveChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatOperationsUnarchiveChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommonOperationsListPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []CustomPropertyDefinition `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r CommonOperationsListPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommonOperationsListPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectUploadOperationsUploadFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DirectUploadOperationsUploadFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectUploadOperationsUploadFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupTagOperationsListTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []GroupTag `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r GroupTagOperationsListTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupTagOperationsListTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupTagOperationsCreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Тег
		Data GroupTag `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r GroupTagOperationsCreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupTagOperationsCreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupTagOperationsDeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r GroupTagOperationsDeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupTagOperationsDeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupTagOperationsGetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Тег
		Data GroupTag `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r GroupTagOperationsGetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupTagOperationsGetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupTagOperationsUpdateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Тег
		Data GroupTag `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r GroupTagOperationsUpdateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupTagOperationsUpdateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupTagOperationsGetTagUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []User `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r GroupTagOperationsGetTagUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupTagOperationsGetTagUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChatMessageOperationsListChatMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Message `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ChatMessageOperationsListChatMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChatMessageOperationsListChatMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MessageOperationsCreateMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Сообщение
		Data Message `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r MessageOperationsCreateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MessageOperationsCreateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MessageOperationsDeleteMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r MessageOperationsDeleteMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MessageOperationsDeleteMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MessageOperationsGetMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Сообщение
		Data Message `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r MessageOperationsGetMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MessageOperationsGetMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MessageOperationsUpdateMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Сообщение
		Data Message `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r MessageOperationsUpdateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MessageOperationsUpdateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPreviewOperationsCreateLinkPreviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r LinkPreviewOperationsCreateLinkPreviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPreviewOperationsCreateLinkPreviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MessageOperationsUnpinMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r MessageOperationsUnpinMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MessageOperationsUnpinMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MessageOperationsPinMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON409      *ApiError
}

// Status returns HTTPResponse.Status
func (r MessageOperationsPinMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MessageOperationsPinMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionOperationsRemoveReactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r ReactionOperationsRemoveReactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionOperationsRemoveReactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionOperationsListReactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Reaction `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ReactionOperationsListReactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionOperationsListReactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionOperationsAddReactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Reaction
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r ReactionOperationsAddReactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionOperationsAddReactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadMemberOperationsListReadMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []int32 `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ReadMemberOperationsListReadMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadMemberOperationsListReadMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThreadOperationsCreateThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Тред
		Data Thread `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r ThreadOperationsCreateThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThreadOperationsCreateThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OAuthOperationsGetTokenInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Информация о текущем OAuth токене
		Data AccessTokenInfo `json:"data"`
	}
	JSON401 *OAuthError
}

// Status returns HTTPResponse.Status
func (r OAuthOperationsGetTokenInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OAuthOperationsGetTokenInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileOperationsGetProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Сотрудник
		Data User `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
}

// Status returns HTTPResponse.Status
func (r ProfileOperationsGetProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileOperationsGetProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileOperationsDeleteStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
}

// Status returns HTTPResponse.Status
func (r ProfileOperationsDeleteStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileOperationsDeleteStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileOperationsGetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *UserStatus `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
}

// Status returns HTTPResponse.Status
func (r ProfileOperationsGetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileOperationsGetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileOperationsUpdateStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Статус пользователя
		Data UserStatus `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r ProfileOperationsUpdateStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileOperationsUpdateStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaskOperationsListTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Task `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
}

// Status returns HTTPResponse.Status
func (r TaskOperationsListTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaskOperationsListTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaskOperationsCreateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Напоминание
		Data Task `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r TaskOperationsCreateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaskOperationsCreateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaskOperationsDeleteTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r TaskOperationsDeleteTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaskOperationsDeleteTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaskOperationsGetTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Напоминание
		Data Task `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r TaskOperationsGetTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaskOperationsGetTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TaskOperationsUpdateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Напоминание
		Data Task `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r TaskOperationsUpdateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TaskOperationsUpdateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThreadOperationsGetThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Тред
		Data Thread `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r ThreadOperationsGetThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThreadOperationsGetThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadOperationsGetUploadParamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UploadParams
	JSON401      *OAuthError
	JSON403      *OAuthError
}

// Status returns HTTPResponse.Status
func (r UploadOperationsGetUploadParamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadOperationsGetUploadParamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserOperationsListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []User `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r UserOperationsListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserOperationsListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserOperationsCreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Сотрудник
		Data User `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r UserOperationsCreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserOperationsCreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserOperationsDeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r UserOperationsDeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserOperationsDeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserOperationsGetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Сотрудник
		Data User `json:"data"`
	}
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
}

// Status returns HTTPResponse.Status
func (r UserOperationsGetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserOperationsGetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserOperationsUpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Сотрудник
		Data User `json:"data"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON404 *ApiError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r UserOperationsUpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserOperationsUpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FormOperationsOpenViewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyResponse
	JSON400      *ApiError
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON410      *ApiError
	JSON422      *ApiError
}

// Status returns HTTPResponse.Status
func (r FormOperationsOpenViewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FormOperationsOpenViewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BotOperationsGetWebhookEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []WebhookEvent `json:"data"`

		// Meta Метаданные пагинации
		Meta *PaginationMeta `json:"meta,omitempty"`
	}
	JSON400 *ApiError
	JSON401 *OAuthError
	JSON403 *OAuthError
	JSON422 *ApiError
}

// Status returns HTTPResponse.Status
func (r BotOperationsGetWebhookEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BotOperationsGetWebhookEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BotOperationsDeleteWebhookEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptyResponse
	JSON401      *OAuthError
	JSON403      *OAuthError
	JSON404      *ApiError
}

// Status returns HTTPResponse.Status
func (r BotOperationsDeleteWebhookEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BotOperationsDeleteWebhookEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SecurityOperationsGetAuditEventsWithResponse request returning *SecurityOperationsGetAuditEventsResponse
func (c *ClientWithResponses) SecurityOperationsGetAuditEventsWithResponse(ctx context.Context, params *SecurityOperationsGetAuditEventsParams, reqEditors ...RequestEditorFn) (*SecurityOperationsGetAuditEventsResponse, error) {
	rsp, err := c.SecurityOperationsGetAuditEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecurityOperationsGetAuditEventsResponse(rsp)
}

// BotOperationsUpdateBotWithBodyWithResponse request with arbitrary body returning *BotOperationsUpdateBotResponse
func (c *ClientWithResponses) BotOperationsUpdateBotWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BotOperationsUpdateBotResponse, error) {
	rsp, err := c.BotOperationsUpdateBotWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBotOperationsUpdateBotResponse(rsp)
}

func (c *ClientWithResponses) BotOperationsUpdateBotWithResponse(ctx context.Context, id int32, body BotOperationsUpdateBotJSONRequestBody, reqEditors ...RequestEditorFn) (*BotOperationsUpdateBotResponse, error) {
	rsp, err := c.BotOperationsUpdateBot(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBotOperationsUpdateBotResponse(rsp)
}

// ChatOperationsListChatsWithResponse request returning *ChatOperationsListChatsResponse
func (c *ClientWithResponses) ChatOperationsListChatsWithResponse(ctx context.Context, params *ChatOperationsListChatsParams, reqEditors ...RequestEditorFn) (*ChatOperationsListChatsResponse, error) {
	rsp, err := c.ChatOperationsListChats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsListChatsResponse(rsp)
}

// ChatOperationsCreateChatWithBodyWithResponse request with arbitrary body returning *ChatOperationsCreateChatResponse
func (c *ClientWithResponses) ChatOperationsCreateChatWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatOperationsCreateChatResponse, error) {
	rsp, err := c.ChatOperationsCreateChatWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsCreateChatResponse(rsp)
}

func (c *ClientWithResponses) ChatOperationsCreateChatWithResponse(ctx context.Context, body ChatOperationsCreateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatOperationsCreateChatResponse, error) {
	rsp, err := c.ChatOperationsCreateChat(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsCreateChatResponse(rsp)
}

// ExportOperationsRequestExportWithBodyWithResponse request with arbitrary body returning *ExportOperationsRequestExportResponse
func (c *ClientWithResponses) ExportOperationsRequestExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportOperationsRequestExportResponse, error) {
	rsp, err := c.ExportOperationsRequestExportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportOperationsRequestExportResponse(rsp)
}

func (c *ClientWithResponses) ExportOperationsRequestExportWithResponse(ctx context.Context, body ExportOperationsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportOperationsRequestExportResponse, error) {
	rsp, err := c.ExportOperationsRequestExport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportOperationsRequestExportResponse(rsp)
}

// ExportOperationsDownloadExportWithResponse request returning *ExportOperationsDownloadExportResponse
func (c *ClientWithResponses) ExportOperationsDownloadExportWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ExportOperationsDownloadExportResponse, error) {
	rsp, err := c.ExportOperationsDownloadExport(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportOperationsDownloadExportResponse(rsp)
}

// ChatOperationsGetChatWithResponse request returning *ChatOperationsGetChatResponse
func (c *ClientWithResponses) ChatOperationsGetChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatOperationsGetChatResponse, error) {
	rsp, err := c.ChatOperationsGetChat(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsGetChatResponse(rsp)
}

// ChatOperationsUpdateChatWithBodyWithResponse request with arbitrary body returning *ChatOperationsUpdateChatResponse
func (c *ClientWithResponses) ChatOperationsUpdateChatWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatOperationsUpdateChatResponse, error) {
	rsp, err := c.ChatOperationsUpdateChatWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsUpdateChatResponse(rsp)
}

func (c *ClientWithResponses) ChatOperationsUpdateChatWithResponse(ctx context.Context, id int32, body ChatOperationsUpdateChatJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatOperationsUpdateChatResponse, error) {
	rsp, err := c.ChatOperationsUpdateChat(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsUpdateChatResponse(rsp)
}

// ChatOperationsArchiveChatWithResponse request returning *ChatOperationsArchiveChatResponse
func (c *ClientWithResponses) ChatOperationsArchiveChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatOperationsArchiveChatResponse, error) {
	rsp, err := c.ChatOperationsArchiveChat(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsArchiveChatResponse(rsp)
}

// ChatMemberOperationsAddTagsWithBodyWithResponse request with arbitrary body returning *ChatMemberOperationsAddTagsResponse
func (c *ClientWithResponses) ChatMemberOperationsAddTagsWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddTagsResponse, error) {
	rsp, err := c.ChatMemberOperationsAddTagsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsAddTagsResponse(rsp)
}

func (c *ClientWithResponses) ChatMemberOperationsAddTagsWithResponse(ctx context.Context, id int32, body ChatMemberOperationsAddTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddTagsResponse, error) {
	rsp, err := c.ChatMemberOperationsAddTags(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsAddTagsResponse(rsp)
}

// ChatMemberOperationsRemoveTagWithResponse request returning *ChatMemberOperationsRemoveTagResponse
func (c *ClientWithResponses) ChatMemberOperationsRemoveTagWithResponse(ctx context.Context, id int32, tagId int32, reqEditors ...RequestEditorFn) (*ChatMemberOperationsRemoveTagResponse, error) {
	rsp, err := c.ChatMemberOperationsRemoveTag(ctx, id, tagId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsRemoveTagResponse(rsp)
}

// ChatMemberOperationsLeaveChatWithResponse request returning *ChatMemberOperationsLeaveChatResponse
func (c *ClientWithResponses) ChatMemberOperationsLeaveChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatMemberOperationsLeaveChatResponse, error) {
	rsp, err := c.ChatMemberOperationsLeaveChat(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsLeaveChatResponse(rsp)
}

// ChatMemberOperationsListMembersWithResponse request returning *ChatMemberOperationsListMembersResponse
func (c *ClientWithResponses) ChatMemberOperationsListMembersWithResponse(ctx context.Context, id int32, params *ChatMemberOperationsListMembersParams, reqEditors ...RequestEditorFn) (*ChatMemberOperationsListMembersResponse, error) {
	rsp, err := c.ChatMemberOperationsListMembers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsListMembersResponse(rsp)
}

// ChatMemberOperationsAddMembersWithBodyWithResponse request with arbitrary body returning *ChatMemberOperationsAddMembersResponse
func (c *ClientWithResponses) ChatMemberOperationsAddMembersWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddMembersResponse, error) {
	rsp, err := c.ChatMemberOperationsAddMembersWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsAddMembersResponse(rsp)
}

func (c *ClientWithResponses) ChatMemberOperationsAddMembersWithResponse(ctx context.Context, id int32, body ChatMemberOperationsAddMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatMemberOperationsAddMembersResponse, error) {
	rsp, err := c.ChatMemberOperationsAddMembers(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsAddMembersResponse(rsp)
}

// ChatMemberOperationsRemoveMemberWithResponse request returning *ChatMemberOperationsRemoveMemberResponse
func (c *ClientWithResponses) ChatMemberOperationsRemoveMemberWithResponse(ctx context.Context, id int32, userId int32, reqEditors ...RequestEditorFn) (*ChatMemberOperationsRemoveMemberResponse, error) {
	rsp, err := c.ChatMemberOperationsRemoveMember(ctx, id, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsRemoveMemberResponse(rsp)
}

// ChatMemberOperationsUpdateMemberRoleWithBodyWithResponse request with arbitrary body returning *ChatMemberOperationsUpdateMemberRoleResponse
func (c *ClientWithResponses) ChatMemberOperationsUpdateMemberRoleWithBodyWithResponse(ctx context.Context, id int32, userId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChatMemberOperationsUpdateMemberRoleResponse, error) {
	rsp, err := c.ChatMemberOperationsUpdateMemberRoleWithBody(ctx, id, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsUpdateMemberRoleResponse(rsp)
}

func (c *ClientWithResponses) ChatMemberOperationsUpdateMemberRoleWithResponse(ctx context.Context, id int32, userId int32, body ChatMemberOperationsUpdateMemberRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*ChatMemberOperationsUpdateMemberRoleResponse, error) {
	rsp, err := c.ChatMemberOperationsUpdateMemberRole(ctx, id, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMemberOperationsUpdateMemberRoleResponse(rsp)
}

// ChatOperationsUnarchiveChatWithResponse request returning *ChatOperationsUnarchiveChatResponse
func (c *ClientWithResponses) ChatOperationsUnarchiveChatWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ChatOperationsUnarchiveChatResponse, error) {
	rsp, err := c.ChatOperationsUnarchiveChat(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatOperationsUnarchiveChatResponse(rsp)
}

// CommonOperationsListPropertiesWithResponse request returning *CommonOperationsListPropertiesResponse
func (c *ClientWithResponses) CommonOperationsListPropertiesWithResponse(ctx context.Context, params *CommonOperationsListPropertiesParams, reqEditors ...RequestEditorFn) (*CommonOperationsListPropertiesResponse, error) {
	rsp, err := c.CommonOperationsListProperties(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommonOperationsListPropertiesResponse(rsp)
}

// DirectUploadOperationsUploadFileWithBodyWithResponse request with arbitrary body returning *DirectUploadOperationsUploadFileResponse
func (c *ClientWithResponses) DirectUploadOperationsUploadFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectUploadOperationsUploadFileResponse, error) {
	rsp, err := c.DirectUploadOperationsUploadFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectUploadOperationsUploadFileResponse(rsp)
}

// GroupTagOperationsListTagsWithResponse request returning *GroupTagOperationsListTagsResponse
func (c *ClientWithResponses) GroupTagOperationsListTagsWithResponse(ctx context.Context, params *GroupTagOperationsListTagsParams, reqEditors ...RequestEditorFn) (*GroupTagOperationsListTagsResponse, error) {
	rsp, err := c.GroupTagOperationsListTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsListTagsResponse(rsp)
}

// GroupTagOperationsCreateTagWithBodyWithResponse request with arbitrary body returning *GroupTagOperationsCreateTagResponse
func (c *ClientWithResponses) GroupTagOperationsCreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupTagOperationsCreateTagResponse, error) {
	rsp, err := c.GroupTagOperationsCreateTagWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsCreateTagResponse(rsp)
}

func (c *ClientWithResponses) GroupTagOperationsCreateTagWithResponse(ctx context.Context, body GroupTagOperationsCreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupTagOperationsCreateTagResponse, error) {
	rsp, err := c.GroupTagOperationsCreateTag(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsCreateTagResponse(rsp)
}

// GroupTagOperationsDeleteTagWithResponse request returning *GroupTagOperationsDeleteTagResponse
func (c *ClientWithResponses) GroupTagOperationsDeleteTagWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*GroupTagOperationsDeleteTagResponse, error) {
	rsp, err := c.GroupTagOperationsDeleteTag(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsDeleteTagResponse(rsp)
}

// GroupTagOperationsGetTagWithResponse request returning *GroupTagOperationsGetTagResponse
func (c *ClientWithResponses) GroupTagOperationsGetTagWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*GroupTagOperationsGetTagResponse, error) {
	rsp, err := c.GroupTagOperationsGetTag(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsGetTagResponse(rsp)
}

// GroupTagOperationsUpdateTagWithBodyWithResponse request with arbitrary body returning *GroupTagOperationsUpdateTagResponse
func (c *ClientWithResponses) GroupTagOperationsUpdateTagWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupTagOperationsUpdateTagResponse, error) {
	rsp, err := c.GroupTagOperationsUpdateTagWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsUpdateTagResponse(rsp)
}

func (c *ClientWithResponses) GroupTagOperationsUpdateTagWithResponse(ctx context.Context, id int32, body GroupTagOperationsUpdateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupTagOperationsUpdateTagResponse, error) {
	rsp, err := c.GroupTagOperationsUpdateTag(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsUpdateTagResponse(rsp)
}

// GroupTagOperationsGetTagUsersWithResponse request returning *GroupTagOperationsGetTagUsersResponse
func (c *ClientWithResponses) GroupTagOperationsGetTagUsersWithResponse(ctx context.Context, id int32, params *GroupTagOperationsGetTagUsersParams, reqEditors ...RequestEditorFn) (*GroupTagOperationsGetTagUsersResponse, error) {
	rsp, err := c.GroupTagOperationsGetTagUsers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupTagOperationsGetTagUsersResponse(rsp)
}

// ChatMessageOperationsListChatMessagesWithResponse request returning *ChatMessageOperationsListChatMessagesResponse
func (c *ClientWithResponses) ChatMessageOperationsListChatMessagesWithResponse(ctx context.Context, params *ChatMessageOperationsListChatMessagesParams, reqEditors ...RequestEditorFn) (*ChatMessageOperationsListChatMessagesResponse, error) {
	rsp, err := c.ChatMessageOperationsListChatMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChatMessageOperationsListChatMessagesResponse(rsp)
}

// MessageOperationsCreateMessageWithBodyWithResponse request with arbitrary body returning *MessageOperationsCreateMessageResponse
func (c *ClientWithResponses) MessageOperationsCreateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MessageOperationsCreateMessageResponse, error) {
	rsp, err := c.MessageOperationsCreateMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsCreateMessageResponse(rsp)
}

func (c *ClientWithResponses) MessageOperationsCreateMessageWithResponse(ctx context.Context, body MessageOperationsCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*MessageOperationsCreateMessageResponse, error) {
	rsp, err := c.MessageOperationsCreateMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsCreateMessageResponse(rsp)
}

// MessageOperationsDeleteMessageWithResponse request returning *MessageOperationsDeleteMessageResponse
func (c *ClientWithResponses) MessageOperationsDeleteMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsDeleteMessageResponse, error) {
	rsp, err := c.MessageOperationsDeleteMessage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsDeleteMessageResponse(rsp)
}

// MessageOperationsGetMessageWithResponse request returning *MessageOperationsGetMessageResponse
func (c *ClientWithResponses) MessageOperationsGetMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsGetMessageResponse, error) {
	rsp, err := c.MessageOperationsGetMessage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsGetMessageResponse(rsp)
}

// MessageOperationsUpdateMessageWithBodyWithResponse request with arbitrary body returning *MessageOperationsUpdateMessageResponse
func (c *ClientWithResponses) MessageOperationsUpdateMessageWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MessageOperationsUpdateMessageResponse, error) {
	rsp, err := c.MessageOperationsUpdateMessageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsUpdateMessageResponse(rsp)
}

func (c *ClientWithResponses) MessageOperationsUpdateMessageWithResponse(ctx context.Context, id int32, body MessageOperationsUpdateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*MessageOperationsUpdateMessageResponse, error) {
	rsp, err := c.MessageOperationsUpdateMessage(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsUpdateMessageResponse(rsp)
}

// LinkPreviewOperationsCreateLinkPreviewsWithBodyWithResponse request with arbitrary body returning *LinkPreviewOperationsCreateLinkPreviewsResponse
func (c *ClientWithResponses) LinkPreviewOperationsCreateLinkPreviewsWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPreviewOperationsCreateLinkPreviewsResponse, error) {
	rsp, err := c.LinkPreviewOperationsCreateLinkPreviewsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPreviewOperationsCreateLinkPreviewsResponse(rsp)
}

func (c *ClientWithResponses) LinkPreviewOperationsCreateLinkPreviewsWithResponse(ctx context.Context, id int32, body LinkPreviewOperationsCreateLinkPreviewsJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPreviewOperationsCreateLinkPreviewsResponse, error) {
	rsp, err := c.LinkPreviewOperationsCreateLinkPreviews(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPreviewOperationsCreateLinkPreviewsResponse(rsp)
}

// MessageOperationsUnpinMessageWithResponse request returning *MessageOperationsUnpinMessageResponse
func (c *ClientWithResponses) MessageOperationsUnpinMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsUnpinMessageResponse, error) {
	rsp, err := c.MessageOperationsUnpinMessage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsUnpinMessageResponse(rsp)
}

// MessageOperationsPinMessageWithResponse request returning *MessageOperationsPinMessageResponse
func (c *ClientWithResponses) MessageOperationsPinMessageWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*MessageOperationsPinMessageResponse, error) {
	rsp, err := c.MessageOperationsPinMessage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMessageOperationsPinMessageResponse(rsp)
}

// ReactionOperationsRemoveReactionWithResponse request returning *ReactionOperationsRemoveReactionResponse
func (c *ClientWithResponses) ReactionOperationsRemoveReactionWithResponse(ctx context.Context, id int32, params *ReactionOperationsRemoveReactionParams, reqEditors ...RequestEditorFn) (*ReactionOperationsRemoveReactionResponse, error) {
	rsp, err := c.ReactionOperationsRemoveReaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionOperationsRemoveReactionResponse(rsp)
}

// ReactionOperationsListReactionsWithResponse request returning *ReactionOperationsListReactionsResponse
func (c *ClientWithResponses) ReactionOperationsListReactionsWithResponse(ctx context.Context, id int32, params *ReactionOperationsListReactionsParams, reqEditors ...RequestEditorFn) (*ReactionOperationsListReactionsResponse, error) {
	rsp, err := c.ReactionOperationsListReactions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionOperationsListReactionsResponse(rsp)
}

// ReactionOperationsAddReactionWithBodyWithResponse request with arbitrary body returning *ReactionOperationsAddReactionResponse
func (c *ClientWithResponses) ReactionOperationsAddReactionWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionOperationsAddReactionResponse, error) {
	rsp, err := c.ReactionOperationsAddReactionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionOperationsAddReactionResponse(rsp)
}

func (c *ClientWithResponses) ReactionOperationsAddReactionWithResponse(ctx context.Context, id int32, body ReactionOperationsAddReactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionOperationsAddReactionResponse, error) {
	rsp, err := c.ReactionOperationsAddReaction(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionOperationsAddReactionResponse(rsp)
}

// ReadMemberOperationsListReadMembersWithResponse request returning *ReadMemberOperationsListReadMembersResponse
func (c *ClientWithResponses) ReadMemberOperationsListReadMembersWithResponse(ctx context.Context, id int32, params *ReadMemberOperationsListReadMembersParams, reqEditors ...RequestEditorFn) (*ReadMemberOperationsListReadMembersResponse, error) {
	rsp, err := c.ReadMemberOperationsListReadMembers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadMemberOperationsListReadMembersResponse(rsp)
}

// ThreadOperationsCreateThreadWithResponse request returning *ThreadOperationsCreateThreadResponse
func (c *ClientWithResponses) ThreadOperationsCreateThreadWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ThreadOperationsCreateThreadResponse, error) {
	rsp, err := c.ThreadOperationsCreateThread(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadOperationsCreateThreadResponse(rsp)
}

// OAuthOperationsGetTokenInfoWithResponse request returning *OAuthOperationsGetTokenInfoResponse
func (c *ClientWithResponses) OAuthOperationsGetTokenInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OAuthOperationsGetTokenInfoResponse, error) {
	rsp, err := c.OAuthOperationsGetTokenInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOAuthOperationsGetTokenInfoResponse(rsp)
}

// ProfileOperationsGetProfileWithResponse request returning *ProfileOperationsGetProfileResponse
func (c *ClientWithResponses) ProfileOperationsGetProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileOperationsGetProfileResponse, error) {
	rsp, err := c.ProfileOperationsGetProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileOperationsGetProfileResponse(rsp)
}

// ProfileOperationsDeleteStatusWithResponse request returning *ProfileOperationsDeleteStatusResponse
func (c *ClientWithResponses) ProfileOperationsDeleteStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileOperationsDeleteStatusResponse, error) {
	rsp, err := c.ProfileOperationsDeleteStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileOperationsDeleteStatusResponse(rsp)
}

// ProfileOperationsGetStatusWithResponse request returning *ProfileOperationsGetStatusResponse
func (c *ClientWithResponses) ProfileOperationsGetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileOperationsGetStatusResponse, error) {
	rsp, err := c.ProfileOperationsGetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileOperationsGetStatusResponse(rsp)
}

// ProfileOperationsUpdateStatusWithBodyWithResponse request with arbitrary body returning *ProfileOperationsUpdateStatusResponse
func (c *ClientWithResponses) ProfileOperationsUpdateStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProfileOperationsUpdateStatusResponse, error) {
	rsp, err := c.ProfileOperationsUpdateStatusWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileOperationsUpdateStatusResponse(rsp)
}

func (c *ClientWithResponses) ProfileOperationsUpdateStatusWithResponse(ctx context.Context, body ProfileOperationsUpdateStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ProfileOperationsUpdateStatusResponse, error) {
	rsp, err := c.ProfileOperationsUpdateStatus(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileOperationsUpdateStatusResponse(rsp)
}

// TaskOperationsListTasksWithResponse request returning *TaskOperationsListTasksResponse
func (c *ClientWithResponses) TaskOperationsListTasksWithResponse(ctx context.Context, params *TaskOperationsListTasksParams, reqEditors ...RequestEditorFn) (*TaskOperationsListTasksResponse, error) {
	rsp, err := c.TaskOperationsListTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaskOperationsListTasksResponse(rsp)
}

// TaskOperationsCreateTaskWithBodyWithResponse request with arbitrary body returning *TaskOperationsCreateTaskResponse
func (c *ClientWithResponses) TaskOperationsCreateTaskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaskOperationsCreateTaskResponse, error) {
	rsp, err := c.TaskOperationsCreateTaskWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaskOperationsCreateTaskResponse(rsp)
}

func (c *ClientWithResponses) TaskOperationsCreateTaskWithResponse(ctx context.Context, body TaskOperationsCreateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*TaskOperationsCreateTaskResponse, error) {
	rsp, err := c.TaskOperationsCreateTask(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaskOperationsCreateTaskResponse(rsp)
}

// TaskOperationsDeleteTaskWithResponse request returning *TaskOperationsDeleteTaskResponse
func (c *ClientWithResponses) TaskOperationsDeleteTaskWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*TaskOperationsDeleteTaskResponse, error) {
	rsp, err := c.TaskOperationsDeleteTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaskOperationsDeleteTaskResponse(rsp)
}

// TaskOperationsGetTaskWithResponse request returning *TaskOperationsGetTaskResponse
func (c *ClientWithResponses) TaskOperationsGetTaskWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*TaskOperationsGetTaskResponse, error) {
	rsp, err := c.TaskOperationsGetTask(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaskOperationsGetTaskResponse(rsp)
}

// TaskOperationsUpdateTaskWithBodyWithResponse request with arbitrary body returning *TaskOperationsUpdateTaskResponse
func (c *ClientWithResponses) TaskOperationsUpdateTaskWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TaskOperationsUpdateTaskResponse, error) {
	rsp, err := c.TaskOperationsUpdateTaskWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaskOperationsUpdateTaskResponse(rsp)
}

func (c *ClientWithResponses) TaskOperationsUpdateTaskWithResponse(ctx context.Context, id int32, body TaskOperationsUpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*TaskOperationsUpdateTaskResponse, error) {
	rsp, err := c.TaskOperationsUpdateTask(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTaskOperationsUpdateTaskResponse(rsp)
}

// ThreadOperationsGetThreadWithResponse request returning *ThreadOperationsGetThreadResponse
func (c *ClientWithResponses) ThreadOperationsGetThreadWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*ThreadOperationsGetThreadResponse, error) {
	rsp, err := c.ThreadOperationsGetThread(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadOperationsGetThreadResponse(rsp)
}

// UploadOperationsGetUploadParamsWithResponse request returning *UploadOperationsGetUploadParamsResponse
func (c *ClientWithResponses) UploadOperationsGetUploadParamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UploadOperationsGetUploadParamsResponse, error) {
	rsp, err := c.UploadOperationsGetUploadParams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadOperationsGetUploadParamsResponse(rsp)
}

// UserOperationsListUsersWithResponse request returning *UserOperationsListUsersResponse
func (c *ClientWithResponses) UserOperationsListUsersWithResponse(ctx context.Context, params *UserOperationsListUsersParams, reqEditors ...RequestEditorFn) (*UserOperationsListUsersResponse, error) {
	rsp, err := c.UserOperationsListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOperationsListUsersResponse(rsp)
}

// UserOperationsCreateUserWithBodyWithResponse request with arbitrary body returning *UserOperationsCreateUserResponse
func (c *ClientWithResponses) UserOperationsCreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserOperationsCreateUserResponse, error) {
	rsp, err := c.UserOperationsCreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOperationsCreateUserResponse(rsp)
}

func (c *ClientWithResponses) UserOperationsCreateUserWithResponse(ctx context.Context, body UserOperationsCreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserOperationsCreateUserResponse, error) {
	rsp, err := c.UserOperationsCreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOperationsCreateUserResponse(rsp)
}

// UserOperationsDeleteUserWithResponse request returning *UserOperationsDeleteUserResponse
func (c *ClientWithResponses) UserOperationsDeleteUserWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*UserOperationsDeleteUserResponse, error) {
	rsp, err := c.UserOperationsDeleteUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOperationsDeleteUserResponse(rsp)
}

// UserOperationsGetUserWithResponse request returning *UserOperationsGetUserResponse
func (c *ClientWithResponses) UserOperationsGetUserWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*UserOperationsGetUserResponse, error) {
	rsp, err := c.UserOperationsGetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOperationsGetUserResponse(rsp)
}

// UserOperationsUpdateUserWithBodyWithResponse request with arbitrary body returning *UserOperationsUpdateUserResponse
func (c *ClientWithResponses) UserOperationsUpdateUserWithBodyWithResponse(ctx context.Context, id int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserOperationsUpdateUserResponse, error) {
	rsp, err := c.UserOperationsUpdateUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOperationsUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UserOperationsUpdateUserWithResponse(ctx context.Context, id int32, body UserOperationsUpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserOperationsUpdateUserResponse, error) {
	rsp, err := c.UserOperationsUpdateUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOperationsUpdateUserResponse(rsp)
}

// FormOperationsOpenViewWithBodyWithResponse request with arbitrary body returning *FormOperationsOpenViewResponse
func (c *ClientWithResponses) FormOperationsOpenViewWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FormOperationsOpenViewResponse, error) {
	rsp, err := c.FormOperationsOpenViewWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFormOperationsOpenViewResponse(rsp)
}

func (c *ClientWithResponses) FormOperationsOpenViewWithResponse(ctx context.Context, body FormOperationsOpenViewJSONRequestBody, reqEditors ...RequestEditorFn) (*FormOperationsOpenViewResponse, error) {
	rsp, err := c.FormOperationsOpenView(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFormOperationsOpenViewResponse(rsp)
}

// BotOperationsGetWebhookEventsWithResponse request returning *BotOperationsGetWebhookEventsResponse
func (c *ClientWithResponses) BotOperationsGetWebhookEventsWithResponse(ctx context.Context, params *BotOperationsGetWebhookEventsParams, reqEditors ...RequestEditorFn) (*BotOperationsGetWebhookEventsResponse, error) {
	rsp, err := c.BotOperationsGetWebhookEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBotOperationsGetWebhookEventsResponse(rsp)
}

// BotOperationsDeleteWebhookEventWithResponse request returning *BotOperationsDeleteWebhookEventResponse
func (c *ClientWithResponses) BotOperationsDeleteWebhookEventWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*BotOperationsDeleteWebhookEventResponse, error) {
	rsp, err := c.BotOperationsDeleteWebhookEvent(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBotOperationsDeleteWebhookEventResponse(rsp)
}

// ParseSecurityOperationsGetAuditEventsResponse parses an HTTP response from a SecurityOperationsGetAuditEventsWithResponse call
func ParseSecurityOperationsGetAuditEventsResponse(rsp *http.Response) (*SecurityOperationsGetAuditEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecurityOperationsGetAuditEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []AuditEvent `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseBotOperationsUpdateBotResponse parses an HTTP response from a BotOperationsUpdateBotWithResponse call
func ParseBotOperationsUpdateBotResponse(rsp *http.Response) (*BotOperationsUpdateBotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BotOperationsUpdateBotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Ответ с данными бота
			Data BotResponse `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatOperationsListChatsResponse parses an HTTP response from a ChatOperationsListChatsWithResponse call
func ParseChatOperationsListChatsResponse(rsp *http.Response) (*ChatOperationsListChatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatOperationsListChatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Chat `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatOperationsCreateChatResponse parses an HTTP response from a ChatOperationsCreateChatWithResponse call
func ParseChatOperationsCreateChatResponse(rsp *http.Response) (*ChatOperationsCreateChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatOperationsCreateChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Чат
			Data Chat `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseExportOperationsRequestExportResponse parses an HTTP response from a ExportOperationsRequestExportWithResponse call
func ParseExportOperationsRequestExportResponse(rsp *http.Response) (*ExportOperationsRequestExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportOperationsRequestExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseExportOperationsDownloadExportResponse parses an HTTP response from a ExportOperationsDownloadExportWithResponse call
func ParseExportOperationsDownloadExportResponse(rsp *http.Response) (*ExportOperationsDownloadExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportOperationsDownloadExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseChatOperationsGetChatResponse parses an HTTP response from a ChatOperationsGetChatWithResponse call
func ParseChatOperationsGetChatResponse(rsp *http.Response) (*ChatOperationsGetChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatOperationsGetChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Чат
			Data Chat `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseChatOperationsUpdateChatResponse parses an HTTP response from a ChatOperationsUpdateChatWithResponse call
func ParseChatOperationsUpdateChatResponse(rsp *http.Response) (*ChatOperationsUpdateChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatOperationsUpdateChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Чат
			Data Chat `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatOperationsArchiveChatResponse parses an HTTP response from a ChatOperationsArchiveChatWithResponse call
func ParseChatOperationsArchiveChatResponse(rsp *http.Response) (*ChatOperationsArchiveChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatOperationsArchiveChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseChatMemberOperationsAddTagsResponse parses an HTTP response from a ChatMemberOperationsAddTagsWithResponse call
func ParseChatMemberOperationsAddTagsResponse(rsp *http.Response) (*ChatMemberOperationsAddTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMemberOperationsAddTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatMemberOperationsRemoveTagResponse parses an HTTP response from a ChatMemberOperationsRemoveTagWithResponse call
func ParseChatMemberOperationsRemoveTagResponse(rsp *http.Response) (*ChatMemberOperationsRemoveTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMemberOperationsRemoveTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseChatMemberOperationsLeaveChatResponse parses an HTTP response from a ChatMemberOperationsLeaveChatWithResponse call
func ParseChatMemberOperationsLeaveChatResponse(rsp *http.Response) (*ChatMemberOperationsLeaveChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMemberOperationsLeaveChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatMemberOperationsListMembersResponse parses an HTTP response from a ChatMemberOperationsListMembersWithResponse call
func ParseChatMemberOperationsListMembersResponse(rsp *http.Response) (*ChatMemberOperationsListMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMemberOperationsListMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []User `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatMemberOperationsAddMembersResponse parses an HTTP response from a ChatMemberOperationsAddMembersWithResponse call
func ParseChatMemberOperationsAddMembersResponse(rsp *http.Response) (*ChatMemberOperationsAddMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMemberOperationsAddMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatMemberOperationsRemoveMemberResponse parses an HTTP response from a ChatMemberOperationsRemoveMemberWithResponse call
func ParseChatMemberOperationsRemoveMemberResponse(rsp *http.Response) (*ChatMemberOperationsRemoveMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMemberOperationsRemoveMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseChatMemberOperationsUpdateMemberRoleResponse parses an HTTP response from a ChatMemberOperationsUpdateMemberRoleWithResponse call
func ParseChatMemberOperationsUpdateMemberRoleResponse(rsp *http.Response) (*ChatMemberOperationsUpdateMemberRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMemberOperationsUpdateMemberRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatOperationsUnarchiveChatResponse parses an HTTP response from a ChatOperationsUnarchiveChatWithResponse call
func ParseChatOperationsUnarchiveChatResponse(rsp *http.Response) (*ChatOperationsUnarchiveChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatOperationsUnarchiveChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCommonOperationsListPropertiesResponse parses an HTTP response from a CommonOperationsListPropertiesWithResponse call
func ParseCommonOperationsListPropertiesResponse(rsp *http.Response) (*CommonOperationsListPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommonOperationsListPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []CustomPropertyDefinition `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDirectUploadOperationsUploadFileResponse parses an HTTP response from a DirectUploadOperationsUploadFileWithResponse call
func ParseDirectUploadOperationsUploadFileResponse(rsp *http.Response) (*DirectUploadOperationsUploadFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectUploadOperationsUploadFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGroupTagOperationsListTagsResponse parses an HTTP response from a GroupTagOperationsListTagsWithResponse call
func ParseGroupTagOperationsListTagsResponse(rsp *http.Response) (*GroupTagOperationsListTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupTagOperationsListTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []GroupTag `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGroupTagOperationsCreateTagResponse parses an HTTP response from a GroupTagOperationsCreateTagWithResponse call
func ParseGroupTagOperationsCreateTagResponse(rsp *http.Response) (*GroupTagOperationsCreateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupTagOperationsCreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Тег
			Data GroupTag `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGroupTagOperationsDeleteTagResponse parses an HTTP response from a GroupTagOperationsDeleteTagWithResponse call
func ParseGroupTagOperationsDeleteTagResponse(rsp *http.Response) (*GroupTagOperationsDeleteTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupTagOperationsDeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGroupTagOperationsGetTagResponse parses an HTTP response from a GroupTagOperationsGetTagWithResponse call
func ParseGroupTagOperationsGetTagResponse(rsp *http.Response) (*GroupTagOperationsGetTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupTagOperationsGetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Тег
			Data GroupTag `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGroupTagOperationsUpdateTagResponse parses an HTTP response from a GroupTagOperationsUpdateTagWithResponse call
func ParseGroupTagOperationsUpdateTagResponse(rsp *http.Response) (*GroupTagOperationsUpdateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupTagOperationsUpdateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Тег
			Data GroupTag `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGroupTagOperationsGetTagUsersResponse parses an HTTP response from a GroupTagOperationsGetTagUsersWithResponse call
func ParseGroupTagOperationsGetTagUsersResponse(rsp *http.Response) (*GroupTagOperationsGetTagUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupTagOperationsGetTagUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []User `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseChatMessageOperationsListChatMessagesResponse parses an HTTP response from a ChatMessageOperationsListChatMessagesWithResponse call
func ParseChatMessageOperationsListChatMessagesResponse(rsp *http.Response) (*ChatMessageOperationsListChatMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChatMessageOperationsListChatMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Message `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMessageOperationsCreateMessageResponse parses an HTTP response from a MessageOperationsCreateMessageWithResponse call
func ParseMessageOperationsCreateMessageResponse(rsp *http.Response) (*MessageOperationsCreateMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MessageOperationsCreateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Сообщение
			Data Message `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMessageOperationsDeleteMessageResponse parses an HTTP response from a MessageOperationsDeleteMessageWithResponse call
func ParseMessageOperationsDeleteMessageResponse(rsp *http.Response) (*MessageOperationsDeleteMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MessageOperationsDeleteMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMessageOperationsGetMessageResponse parses an HTTP response from a MessageOperationsGetMessageWithResponse call
func ParseMessageOperationsGetMessageResponse(rsp *http.Response) (*MessageOperationsGetMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MessageOperationsGetMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Сообщение
			Data Message `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMessageOperationsUpdateMessageResponse parses an HTTP response from a MessageOperationsUpdateMessageWithResponse call
func ParseMessageOperationsUpdateMessageResponse(rsp *http.Response) (*MessageOperationsUpdateMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MessageOperationsUpdateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Сообщение
			Data Message `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseLinkPreviewOperationsCreateLinkPreviewsResponse parses an HTTP response from a LinkPreviewOperationsCreateLinkPreviewsWithResponse call
func ParseLinkPreviewOperationsCreateLinkPreviewsResponse(rsp *http.Response) (*LinkPreviewOperationsCreateLinkPreviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkPreviewOperationsCreateLinkPreviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMessageOperationsUnpinMessageResponse parses an HTTP response from a MessageOperationsUnpinMessageWithResponse call
func ParseMessageOperationsUnpinMessageResponse(rsp *http.Response) (*MessageOperationsUnpinMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MessageOperationsUnpinMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMessageOperationsPinMessageResponse parses an HTTP response from a MessageOperationsPinMessageWithResponse call
func ParseMessageOperationsPinMessageResponse(rsp *http.Response) (*MessageOperationsPinMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MessageOperationsPinMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseReactionOperationsRemoveReactionResponse parses an HTTP response from a ReactionOperationsRemoveReactionWithResponse call
func ParseReactionOperationsRemoveReactionResponse(rsp *http.Response) (*ReactionOperationsRemoveReactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionOperationsRemoveReactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionOperationsListReactionsResponse parses an HTTP response from a ReactionOperationsListReactionsWithResponse call
func ParseReactionOperationsListReactionsResponse(rsp *http.Response) (*ReactionOperationsListReactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionOperationsListReactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Reaction `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionOperationsAddReactionResponse parses an HTTP response from a ReactionOperationsAddReactionWithResponse call
func ParseReactionOperationsAddReactionResponse(rsp *http.Response) (*ReactionOperationsAddReactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionOperationsAddReactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReadMemberOperationsListReadMembersResponse parses an HTTP response from a ReadMemberOperationsListReadMembersWithResponse call
func ParseReadMemberOperationsListReadMembersResponse(rsp *http.Response) (*ReadMemberOperationsListReadMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadMemberOperationsListReadMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []int32 `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseThreadOperationsCreateThreadResponse parses an HTTP response from a ThreadOperationsCreateThreadWithResponse call
func ParseThreadOperationsCreateThreadResponse(rsp *http.Response) (*ThreadOperationsCreateThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThreadOperationsCreateThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Тред
			Data Thread `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOAuthOperationsGetTokenInfoResponse parses an HTTP response from a OAuthOperationsGetTokenInfoWithResponse call
func ParseOAuthOperationsGetTokenInfoResponse(rsp *http.Response) (*OAuthOperationsGetTokenInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OAuthOperationsGetTokenInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Информация о текущем OAuth токене
			Data AccessTokenInfo `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseProfileOperationsGetProfileResponse parses an HTTP response from a ProfileOperationsGetProfileWithResponse call
func ParseProfileOperationsGetProfileResponse(rsp *http.Response) (*ProfileOperationsGetProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileOperationsGetProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Сотрудник
			Data User `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProfileOperationsDeleteStatusResponse parses an HTTP response from a ProfileOperationsDeleteStatusWithResponse call
func ParseProfileOperationsDeleteStatusResponse(rsp *http.Response) (*ProfileOperationsDeleteStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileOperationsDeleteStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProfileOperationsGetStatusResponse parses an HTTP response from a ProfileOperationsGetStatusWithResponse call
func ParseProfileOperationsGetStatusResponse(rsp *http.Response) (*ProfileOperationsGetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileOperationsGetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *UserStatus `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProfileOperationsUpdateStatusResponse parses an HTTP response from a ProfileOperationsUpdateStatusWithResponse call
func ParseProfileOperationsUpdateStatusResponse(rsp *http.Response) (*ProfileOperationsUpdateStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileOperationsUpdateStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Статус пользователя
			Data UserStatus `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTaskOperationsListTasksResponse parses an HTTP response from a TaskOperationsListTasksWithResponse call
func ParseTaskOperationsListTasksResponse(rsp *http.Response) (*TaskOperationsListTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaskOperationsListTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Task `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTaskOperationsCreateTaskResponse parses an HTTP response from a TaskOperationsCreateTaskWithResponse call
func ParseTaskOperationsCreateTaskResponse(rsp *http.Response) (*TaskOperationsCreateTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaskOperationsCreateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Напоминание
			Data Task `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTaskOperationsDeleteTaskResponse parses an HTTP response from a TaskOperationsDeleteTaskWithResponse call
func ParseTaskOperationsDeleteTaskResponse(rsp *http.Response) (*TaskOperationsDeleteTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaskOperationsDeleteTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTaskOperationsGetTaskResponse parses an HTTP response from a TaskOperationsGetTaskWithResponse call
func ParseTaskOperationsGetTaskResponse(rsp *http.Response) (*TaskOperationsGetTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaskOperationsGetTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Напоминание
			Data Task `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTaskOperationsUpdateTaskResponse parses an HTTP response from a TaskOperationsUpdateTaskWithResponse call
func ParseTaskOperationsUpdateTaskResponse(rsp *http.Response) (*TaskOperationsUpdateTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TaskOperationsUpdateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Напоминание
			Data Task `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseThreadOperationsGetThreadResponse parses an HTTP response from a ThreadOperationsGetThreadWithResponse call
func ParseThreadOperationsGetThreadResponse(rsp *http.Response) (*ThreadOperationsGetThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThreadOperationsGetThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Тред
			Data Thread `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadOperationsGetUploadParamsResponse parses an HTTP response from a UploadOperationsGetUploadParamsWithResponse call
func ParseUploadOperationsGetUploadParamsResponse(rsp *http.Response) (*UploadOperationsGetUploadParamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadOperationsGetUploadParamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UploadParams
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserOperationsListUsersResponse parses an HTTP response from a UserOperationsListUsersWithResponse call
func ParseUserOperationsListUsersResponse(rsp *http.Response) (*UserOperationsListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserOperationsListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []User `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUserOperationsCreateUserResponse parses an HTTP response from a UserOperationsCreateUserWithResponse call
func ParseUserOperationsCreateUserResponse(rsp *http.Response) (*UserOperationsCreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserOperationsCreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Сотрудник
			Data User `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUserOperationsDeleteUserResponse parses an HTTP response from a UserOperationsDeleteUserWithResponse call
func ParseUserOperationsDeleteUserResponse(rsp *http.Response) (*UserOperationsDeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserOperationsDeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserOperationsGetUserResponse parses an HTTP response from a UserOperationsGetUserWithResponse call
func ParseUserOperationsGetUserResponse(rsp *http.Response) (*UserOperationsGetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserOperationsGetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Сотрудник
			Data User `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserOperationsUpdateUserResponse parses an HTTP response from a UserOperationsUpdateUserWithResponse call
func ParseUserOperationsUpdateUserResponse(rsp *http.Response) (*UserOperationsUpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserOperationsUpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Сотрудник
			Data User `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseFormOperationsOpenViewResponse parses an HTTP response from a FormOperationsOpenViewWithResponse call
func ParseFormOperationsOpenViewResponse(rsp *http.Response) (*FormOperationsOpenViewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FormOperationsOpenViewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseBotOperationsGetWebhookEventsResponse parses an HTTP response from a BotOperationsGetWebhookEventsWithResponse call
func ParseBotOperationsGetWebhookEventsResponse(rsp *http.Response) (*BotOperationsGetWebhookEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BotOperationsGetWebhookEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []WebhookEvent `json:"data"`

			// Meta Метаданные пагинации
			Meta *PaginationMeta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseBotOperationsDeleteWebhookEventResponse parses an HTTP response from a BotOperationsDeleteWebhookEventWithResponse call
func ParseBotOperationsDeleteWebhookEventResponse(rsp *http.Response) (*BotOperationsDeleteWebhookEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BotOperationsDeleteWebhookEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest OAuthError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApiError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
